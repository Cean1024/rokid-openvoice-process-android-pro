// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: speech.proto

#define INTERNAL_SUPPRESS_PROTOBUF_FIELD_DEPRECATION
#include "speech.pb.h"

#include <algorithm>

#include <google/protobuf/stubs/common.h>
#include <google/protobuf/stubs/port.h>
#include <google/protobuf/stubs/once.h>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/wire_format_lite_inl.h>
#include <google/protobuf/descriptor.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/reflection_ops.h>
#include <google/protobuf/wire_format.h>
// @@protoc_insertion_point(includes)

namespace rokid {
namespace open {

namespace {

const ::google::protobuf::Descriptor* AsrRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AsrRequest_reflection_ = NULL;
struct AsrRequestOneofInstance {
  const ::rokid::open::AsrHeader* header_;
  ::google::protobuf::internal::ArenaStringPtr voice_;
}* AsrRequest_default_oneof_instance_ = NULL;
const ::google::protobuf::Descriptor* AsrHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AsrHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* AsrResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  AsrResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* NlpRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NlpRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* NlpHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NlpHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* NlpResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  NlpResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* TtsRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TtsRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* TtsHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TtsHeader_reflection_ = NULL;
const ::google::protobuf::Descriptor* TtsResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TtsResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* VoiceSpeechRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VoiceSpeechRequest_reflection_ = NULL;
struct VoiceSpeechRequestOneofInstance {
  const ::rokid::open::SpeechHeader* header_;
  ::google::protobuf::internal::ArenaStringPtr voice_;
}* VoiceSpeechRequest_default_oneof_instance_ = NULL;
const ::google::protobuf::Descriptor* VoiceSpeechResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  VoiceSpeechResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* TextSpeechRequest_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TextSpeechRequest_reflection_ = NULL;
const ::google::protobuf::Descriptor* TextSpeechResponse_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  TextSpeechResponse_reflection_ = NULL;
const ::google::protobuf::Descriptor* SpeechHeader_descriptor_ = NULL;
const ::google::protobuf::internal::GeneratedMessageReflection*
  SpeechHeader_reflection_ = NULL;

}  // namespace


void protobuf_AssignDesc_speech_2eproto() GOOGLE_ATTRIBUTE_COLD;
void protobuf_AssignDesc_speech_2eproto() {
  protobuf_AddDesc_speech_2eproto();
  const ::google::protobuf::FileDescriptor* file =
    ::google::protobuf::DescriptorPool::generated_pool()->FindFileByName(
      "speech.proto");
  GOOGLE_CHECK(file != NULL);
  AsrRequest_descriptor_ = file->message_type(0);
  static const int AsrRequest_offsets_[3] = {
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(AsrRequest_default_oneof_instance_, header_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(AsrRequest_default_oneof_instance_, voice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AsrRequest, request_content_),
  };
  AsrRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AsrRequest_descriptor_,
      AsrRequest::internal_default_instance(),
      AsrRequest_offsets_,
      -1,
      -1,
      -1,
      AsrRequest_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AsrRequest, _oneof_case_[0]),
      sizeof(AsrRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AsrRequest, _internal_metadata_));
  AsrHeader_descriptor_ = file->message_type(1);
  static const int AsrHeader_offsets_[4] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AsrHeader, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AsrHeader, lang_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AsrHeader, codec_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AsrHeader, vt_),
  };
  AsrHeader_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AsrHeader_descriptor_,
      AsrHeader::internal_default_instance(),
      AsrHeader_offsets_,
      -1,
      -1,
      -1,
      sizeof(AsrHeader),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AsrHeader, _internal_metadata_));
  AsrResponse_descriptor_ = file->message_type(2);
  static const int AsrResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AsrResponse, asr_),
  };
  AsrResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      AsrResponse_descriptor_,
      AsrResponse::internal_default_instance(),
      AsrResponse_offsets_,
      -1,
      -1,
      -1,
      sizeof(AsrResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(AsrResponse, _internal_metadata_));
  NlpRequest_descriptor_ = file->message_type(3);
  static const int NlpRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NlpRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NlpRequest, asr_),
  };
  NlpRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NlpRequest_descriptor_,
      NlpRequest::internal_default_instance(),
      NlpRequest_offsets_,
      -1,
      -1,
      -1,
      sizeof(NlpRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NlpRequest, _internal_metadata_));
  NlpHeader_descriptor_ = file->message_type(4);
  static const int NlpHeader_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NlpHeader, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NlpHeader, lang_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NlpHeader, cdomain_),
  };
  NlpHeader_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NlpHeader_descriptor_,
      NlpHeader::internal_default_instance(),
      NlpHeader_offsets_,
      -1,
      -1,
      -1,
      sizeof(NlpHeader),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NlpHeader, _internal_metadata_));
  NlpResponse_descriptor_ = file->message_type(5);
  static const int NlpResponse_offsets_[1] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NlpResponse, nlp_),
  };
  NlpResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      NlpResponse_descriptor_,
      NlpResponse::internal_default_instance(),
      NlpResponse_offsets_,
      -1,
      -1,
      -1,
      sizeof(NlpResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(NlpResponse, _internal_metadata_));
  TtsRequest_descriptor_ = file->message_type(6);
  static const int TtsRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TtsRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TtsRequest, text_),
  };
  TtsRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TtsRequest_descriptor_,
      TtsRequest::internal_default_instance(),
      TtsRequest_offsets_,
      -1,
      -1,
      -1,
      sizeof(TtsRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TtsRequest, _internal_metadata_));
  TtsHeader_descriptor_ = file->message_type(7);
  static const int TtsHeader_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TtsHeader, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TtsHeader, declaimer_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TtsHeader, codec_),
  };
  TtsHeader_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TtsHeader_descriptor_,
      TtsHeader::internal_default_instance(),
      TtsHeader_offsets_,
      -1,
      -1,
      -1,
      sizeof(TtsHeader),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TtsHeader, _internal_metadata_));
  TtsResponse_descriptor_ = file->message_type(8);
  static const int TtsResponse_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TtsResponse, text_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TtsResponse, voice_),
  };
  TtsResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TtsResponse_descriptor_,
      TtsResponse::internal_default_instance(),
      TtsResponse_offsets_,
      -1,
      -1,
      -1,
      sizeof(TtsResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TtsResponse, _internal_metadata_));
  VoiceSpeechRequest_descriptor_ = file->message_type(9);
  static const int VoiceSpeechRequest_offsets_[3] = {
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(VoiceSpeechRequest_default_oneof_instance_, header_),
    PROTO2_GENERATED_DEFAULT_ONEOF_FIELD_OFFSET(VoiceSpeechRequest_default_oneof_instance_, voice_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VoiceSpeechRequest, request_content_),
  };
  VoiceSpeechRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      VoiceSpeechRequest_descriptor_,
      VoiceSpeechRequest::internal_default_instance(),
      VoiceSpeechRequest_offsets_,
      -1,
      -1,
      -1,
      VoiceSpeechRequest_default_oneof_instance_,
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VoiceSpeechRequest, _oneof_case_[0]),
      sizeof(VoiceSpeechRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VoiceSpeechRequest, _internal_metadata_));
  VoiceSpeechResponse_descriptor_ = file->message_type(10);
  static const int VoiceSpeechResponse_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VoiceSpeechResponse, asr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VoiceSpeechResponse, nlp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VoiceSpeechResponse, action_),
  };
  VoiceSpeechResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      VoiceSpeechResponse_descriptor_,
      VoiceSpeechResponse::internal_default_instance(),
      VoiceSpeechResponse_offsets_,
      -1,
      -1,
      -1,
      sizeof(VoiceSpeechResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(VoiceSpeechResponse, _internal_metadata_));
  TextSpeechRequest_descriptor_ = file->message_type(11);
  static const int TextSpeechRequest_offsets_[2] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TextSpeechRequest, header_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TextSpeechRequest, asr_),
  };
  TextSpeechRequest_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TextSpeechRequest_descriptor_,
      TextSpeechRequest::internal_default_instance(),
      TextSpeechRequest_offsets_,
      -1,
      -1,
      -1,
      sizeof(TextSpeechRequest),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TextSpeechRequest, _internal_metadata_));
  TextSpeechResponse_descriptor_ = file->message_type(12);
  static const int TextSpeechResponse_offsets_[3] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TextSpeechResponse, asr_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TextSpeechResponse, nlp_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TextSpeechResponse, action_),
  };
  TextSpeechResponse_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      TextSpeechResponse_descriptor_,
      TextSpeechResponse::internal_default_instance(),
      TextSpeechResponse_offsets_,
      -1,
      -1,
      -1,
      sizeof(TextSpeechResponse),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(TextSpeechResponse, _internal_metadata_));
  SpeechHeader_descriptor_ = file->message_type(13);
  static const int SpeechHeader_offsets_[6] = {
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpeechHeader, id_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpeechHeader, language_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpeechHeader, codec_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpeechHeader, vt_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpeechHeader, cdomain_),
    GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpeechHeader, device_),
  };
  SpeechHeader_reflection_ =
    ::google::protobuf::internal::GeneratedMessageReflection::NewGeneratedMessageReflection(
      SpeechHeader_descriptor_,
      SpeechHeader::internal_default_instance(),
      SpeechHeader_offsets_,
      -1,
      -1,
      -1,
      sizeof(SpeechHeader),
      GOOGLE_PROTOBUF_GENERATED_MESSAGE_FIELD_OFFSET(SpeechHeader, _internal_metadata_));
}

namespace {

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AssignDescriptors_once_);
void protobuf_AssignDescriptorsOnce() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AssignDescriptors_once_,
                 &protobuf_AssignDesc_speech_2eproto);
}

void protobuf_RegisterTypes(const ::std::string&) GOOGLE_ATTRIBUTE_COLD;
void protobuf_RegisterTypes(const ::std::string&) {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AsrRequest_descriptor_, AsrRequest::internal_default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AsrHeader_descriptor_, AsrHeader::internal_default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      AsrResponse_descriptor_, AsrResponse::internal_default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NlpRequest_descriptor_, NlpRequest::internal_default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NlpHeader_descriptor_, NlpHeader::internal_default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      NlpResponse_descriptor_, NlpResponse::internal_default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TtsRequest_descriptor_, TtsRequest::internal_default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TtsHeader_descriptor_, TtsHeader::internal_default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TtsResponse_descriptor_, TtsResponse::internal_default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      VoiceSpeechRequest_descriptor_, VoiceSpeechRequest::internal_default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      VoiceSpeechResponse_descriptor_, VoiceSpeechResponse::internal_default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TextSpeechRequest_descriptor_, TextSpeechRequest::internal_default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      TextSpeechResponse_descriptor_, TextSpeechResponse::internal_default_instance());
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedMessage(
      SpeechHeader_descriptor_, SpeechHeader::internal_default_instance());
}

}  // namespace

void protobuf_ShutdownFile_speech_2eproto() {
  AsrRequest_default_instance_.Shutdown();
  delete AsrRequest_default_oneof_instance_;
  delete AsrRequest_reflection_;
  AsrHeader_default_instance_.Shutdown();
  delete AsrHeader_reflection_;
  AsrResponse_default_instance_.Shutdown();
  delete AsrResponse_reflection_;
  NlpRequest_default_instance_.Shutdown();
  delete NlpRequest_reflection_;
  NlpHeader_default_instance_.Shutdown();
  delete NlpHeader_reflection_;
  NlpResponse_default_instance_.Shutdown();
  delete NlpResponse_reflection_;
  TtsRequest_default_instance_.Shutdown();
  delete TtsRequest_reflection_;
  TtsHeader_default_instance_.Shutdown();
  delete TtsHeader_reflection_;
  TtsResponse_default_instance_.Shutdown();
  delete TtsResponse_reflection_;
  VoiceSpeechRequest_default_instance_.Shutdown();
  delete VoiceSpeechRequest_default_oneof_instance_;
  delete VoiceSpeechRequest_reflection_;
  VoiceSpeechResponse_default_instance_.Shutdown();
  delete VoiceSpeechResponse_reflection_;
  TextSpeechRequest_default_instance_.Shutdown();
  delete TextSpeechRequest_reflection_;
  TextSpeechResponse_default_instance_.Shutdown();
  delete TextSpeechResponse_reflection_;
  SpeechHeader_default_instance_.Shutdown();
  delete SpeechHeader_reflection_;
}

void protobuf_InitDefaults_speech_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  ::google::protobuf::internal::GetEmptyString();
  AsrRequest_default_instance_.DefaultConstruct();
  AsrRequest_default_oneof_instance_ = new AsrRequestOneofInstance();
  ::google::protobuf::internal::GetEmptyString();
  AsrHeader_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  AsrResponse_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  NlpRequest_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  NlpHeader_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  NlpResponse_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  TtsRequest_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  TtsHeader_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  TtsResponse_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  VoiceSpeechRequest_default_instance_.DefaultConstruct();
  VoiceSpeechRequest_default_oneof_instance_ = new VoiceSpeechRequestOneofInstance();
  ::google::protobuf::internal::GetEmptyString();
  VoiceSpeechResponse_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  TextSpeechRequest_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  TextSpeechResponse_default_instance_.DefaultConstruct();
  ::google::protobuf::internal::GetEmptyString();
  SpeechHeader_default_instance_.DefaultConstruct();
  AsrRequest_default_instance_.get_mutable()->InitAsDefaultInstance();
  AsrHeader_default_instance_.get_mutable()->InitAsDefaultInstance();
  AsrResponse_default_instance_.get_mutable()->InitAsDefaultInstance();
  NlpRequest_default_instance_.get_mutable()->InitAsDefaultInstance();
  NlpHeader_default_instance_.get_mutable()->InitAsDefaultInstance();
  NlpResponse_default_instance_.get_mutable()->InitAsDefaultInstance();
  TtsRequest_default_instance_.get_mutable()->InitAsDefaultInstance();
  TtsHeader_default_instance_.get_mutable()->InitAsDefaultInstance();
  TtsResponse_default_instance_.get_mutable()->InitAsDefaultInstance();
  VoiceSpeechRequest_default_instance_.get_mutable()->InitAsDefaultInstance();
  VoiceSpeechResponse_default_instance_.get_mutable()->InitAsDefaultInstance();
  TextSpeechRequest_default_instance_.get_mutable()->InitAsDefaultInstance();
  TextSpeechResponse_default_instance_.get_mutable()->InitAsDefaultInstance();
  SpeechHeader_default_instance_.get_mutable()->InitAsDefaultInstance();
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_InitDefaults_speech_2eproto_once_);
void protobuf_InitDefaults_speech_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_InitDefaults_speech_2eproto_once_,
                 &protobuf_InitDefaults_speech_2eproto_impl);
}
void protobuf_AddDesc_speech_2eproto_impl() {
  GOOGLE_PROTOBUF_VERIFY_VERSION;

  protobuf_InitDefaults_speech_2eproto();
  ::google::protobuf::DescriptorPool::InternalAddGeneratedFile(
    "\n\014speech.proto\022\nrokid.open\"Y\n\nAsrRequest"
    "\022\'\n\006header\030\001 \001(\0132\025.rokid.open.AsrHeaderH"
    "\000\022\017\n\005voice\030\002 \001(\014H\000B\021\n\017request_content\"@\n"
    "\tAsrHeader\022\n\n\002id\030\001 \001(\005\022\014\n\004lang\030\002 \001(\t\022\r\n\005"
    "codec\030\003 \001(\t\022\n\n\002vt\030\004 \001(\t\"\032\n\013AsrResponse\022\013"
    "\n\003asr\030\001 \001(\t\"@\n\nNlpRequest\022%\n\006header\030\001 \001("
    "\0132\025.rokid.open.NlpHeader\022\013\n\003asr\030\002 \001(\t\"6\n"
    "\tNlpHeader\022\n\n\002id\030\001 \001(\005\022\014\n\004lang\030\002 \001(\t\022\017\n\007"
    "cdomain\030\003 \001(\t\"\032\n\013NlpResponse\022\013\n\003nlp\030\001 \001("
    "\t\"A\n\nTtsRequest\022%\n\006header\030\001 \001(\0132\025.rokid."
    "open.TtsHeader\022\014\n\004text\030\002 \001(\t\"9\n\tTtsHeade"
    "r\022\n\n\002id\030\001 \001(\005\022\021\n\tdeclaimer\030\002 \001(\t\022\r\n\005code"
    "c\030\003 \001(\t\"*\n\013TtsResponse\022\014\n\004text\030\001 \001(\t\022\r\n\005"
    "voice\030\002 \001(\014\"d\n\022VoiceSpeechRequest\022*\n\006hea"
    "der\030\001 \001(\0132\030.rokid.open.SpeechHeaderH\000\022\017\n"
    "\005voice\030\002 \001(\014H\000B\021\n\017request_content\"\?\n\023Voi"
    "ceSpeechResponse\022\013\n\003asr\030\001 \001(\t\022\013\n\003nlp\030\002 \001"
    "(\t\022\016\n\006action\030\003 \001(\t\"J\n\021TextSpeechRequest\022"
    "(\n\006header\030\001 \001(\0132\030.rokid.open.SpeechHeade"
    "r\022\013\n\003asr\030\002 \001(\t\">\n\022TextSpeechResponse\022\013\n\003"
    "asr\030\001 \001(\t\022\013\n\003nlp\030\002 \001(\t\022\016\n\006action\030\003 \001(\t\"h"
    "\n\014SpeechHeader\022\n\n\002id\030\001 \001(\005\022\020\n\010language\030\002"
    " \001(\t\022\r\n\005codec\030\003 \001(\t\022\n\n\002vt\030\004 \001(\t\022\017\n\007cdoma"
    "in\030\005 \001(\t\022\016\n\006device\030\006 \001(\t2\332\002\n\006Speech\022<\n\003a"
    "sr\022\026.rokid.open.AsrRequest\032\027.rokid.open."
    "AsrResponse\"\000(\0010\001\0228\n\003nlp\022\026.rokid.open.Nl"
    "pRequest\032\027.rokid.open.NlpResponse\"\000\022:\n\003t"
    "ts\022\026.rokid.open.TtsRequest\032\027.rokid.open."
    "TtsResponse\"\0000\001\022P\n\007speechv\022\036.rokid.open."
    "VoiceSpeechRequest\032\037.rokid.open.VoiceSpe"
    "echResponse\"\000(\0010\001\022J\n\007speecht\022\035.rokid.ope"
    "n.TextSpeechRequest\032\036.rokid.open.TextSpe"
    "echResponse\"\000b\006proto3", 1301);
  ::google::protobuf::MessageFactory::InternalRegisterGeneratedFile(
    "speech.proto", &protobuf_RegisterTypes);
  ::google::protobuf::internal::OnShutdown(&protobuf_ShutdownFile_speech_2eproto);
}

GOOGLE_PROTOBUF_DECLARE_ONCE(protobuf_AddDesc_speech_2eproto_once_);
void protobuf_AddDesc_speech_2eproto() {
  ::google::protobuf::GoogleOnceInit(&protobuf_AddDesc_speech_2eproto_once_,
                 &protobuf_AddDesc_speech_2eproto_impl);
}
// Force AddDescriptors() to be called at static initialization time.
struct StaticDescriptorInitializer_speech_2eproto {
  StaticDescriptorInitializer_speech_2eproto() {
    protobuf_AddDesc_speech_2eproto();
  }
} static_descriptor_initializer_speech_2eproto_;

namespace {

static void MergeFromFail(int line) GOOGLE_ATTRIBUTE_COLD GOOGLE_ATTRIBUTE_NORETURN;
static void MergeFromFail(int line) {
  ::google::protobuf::internal::MergeFromFail(__FILE__, line);
}

}  // namespace


// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AsrRequest::kHeaderFieldNumber;
const int AsrRequest::kVoiceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AsrRequest::AsrRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_speech_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:rokid.open.AsrRequest)
}

void AsrRequest::InitAsDefaultInstance() {
  AsrRequest_default_oneof_instance_->header_ = const_cast< ::rokid::open::AsrHeader*>(
      ::rokid::open::AsrHeader::internal_default_instance());
  AsrRequest_default_oneof_instance_->voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

AsrRequest::AsrRequest(const AsrRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:rokid.open.AsrRequest)
}

void AsrRequest::SharedCtor() {
  clear_has_request_content();
  _cached_size_ = 0;
}

AsrRequest::~AsrRequest() {
  // @@protoc_insertion_point(destructor:rokid.open.AsrRequest)
  SharedDtor();
}

void AsrRequest::SharedDtor() {
  if (has_request_content()) {
    clear_request_content();
  }
}

void AsrRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AsrRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AsrRequest_descriptor_;
}

const AsrRequest& AsrRequest::default_instance() {
  protobuf_InitDefaults_speech_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<AsrRequest> AsrRequest_default_instance_;

AsrRequest* AsrRequest::New(::google::protobuf::Arena* arena) const {
  AsrRequest* n = new AsrRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AsrRequest::clear_request_content() {
// @@protoc_insertion_point(one_of_clear_start:rokid.open.AsrRequest)
  switch (request_content_case()) {
    case kHeader: {
      delete request_content_.header_;
      break;
    }
    case kVoice: {
      request_content_.voice_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case REQUEST_CONTENT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = REQUEST_CONTENT_NOT_SET;
}


void AsrRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:rokid.open.AsrRequest)
  clear_request_content();
}

bool AsrRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:rokid.open.AsrRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .rokid.open.AsrHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        goto after_voice;
        break;
      }

      // optional bytes voice = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_voice()));
        } else {
          goto handle_unusual;
        }
       after_voice:
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:rokid.open.AsrRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:rokid.open.AsrRequest)
  return false;
#undef DO_
}

void AsrRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:rokid.open.AsrRequest)
  // optional .rokid.open.AsrHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *request_content_.header_, output);
  }

  // optional bytes voice = 2;
  if (has_voice()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->voice(), output);
  }

  // @@protoc_insertion_point(serialize_end:rokid.open.AsrRequest)
}

::google::protobuf::uint8* AsrRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:rokid.open.AsrRequest)
  // optional .rokid.open.AsrHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *request_content_.header_, false, target);
  }

  // optional bytes voice = 2;
  if (has_voice()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->voice(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:rokid.open.AsrRequest)
  return target;
}

size_t AsrRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rokid.open.AsrRequest)
  size_t total_size = 0;

  switch (request_content_case()) {
    // optional .rokid.open.AsrHeader header = 1;
    case kHeader: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *request_content_.header_);
      break;
    }
    // optional bytes voice = 2;
    case kVoice: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->voice());
      break;
    }
    case REQUEST_CONTENT_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AsrRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:rokid.open.AsrRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const AsrRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const AsrRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:rokid.open.AsrRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:rokid.open.AsrRequest)
    UnsafeMergeFrom(*source);
  }
}

void AsrRequest::MergeFrom(const AsrRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rokid.open.AsrRequest)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void AsrRequest::UnsafeMergeFrom(const AsrRequest& from) {
  GOOGLE_DCHECK(&from != this);
  switch (from.request_content_case()) {
    case kHeader: {
      mutable_header()->::rokid::open::AsrHeader::MergeFrom(from.header());
      break;
    }
    case kVoice: {
      set_voice(from.voice());
      break;
    }
    case REQUEST_CONTENT_NOT_SET: {
      break;
    }
  }
}

void AsrRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:rokid.open.AsrRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AsrRequest::CopyFrom(const AsrRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rokid.open.AsrRequest)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool AsrRequest::IsInitialized() const {

  return true;
}

void AsrRequest::Swap(AsrRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AsrRequest::InternalSwap(AsrRequest* other) {
  std::swap(request_content_, other->request_content_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AsrRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AsrRequest_descriptor_;
  metadata.reflection = AsrRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AsrRequest

// optional .rokid.open.AsrHeader header = 1;
bool AsrRequest::has_header() const {
  return request_content_case() == kHeader;
}
void AsrRequest::set_has_header() {
  _oneof_case_[0] = kHeader;
}
void AsrRequest::clear_header() {
  if (has_header()) {
    delete request_content_.header_;
    clear_has_request_content();
  }
}
 const ::rokid::open::AsrHeader& AsrRequest::header() const {
  // @@protoc_insertion_point(field_get:rokid.open.AsrRequest.header)
  return has_header()
      ? *request_content_.header_
      : ::rokid::open::AsrHeader::default_instance();
}
::rokid::open::AsrHeader* AsrRequest::mutable_header() {
  if (!has_header()) {
    clear_request_content();
    set_has_header();
    request_content_.header_ = new ::rokid::open::AsrHeader;
  }
  // @@protoc_insertion_point(field_mutable:rokid.open.AsrRequest.header)
  return request_content_.header_;
}
::rokid::open::AsrHeader* AsrRequest::release_header() {
  // @@protoc_insertion_point(field_release:rokid.open.AsrRequest.header)
  if (has_header()) {
    clear_has_request_content();
    ::rokid::open::AsrHeader* temp = request_content_.header_;
    request_content_.header_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void AsrRequest::set_allocated_header(::rokid::open::AsrHeader* header) {
  clear_request_content();
  if (header) {
    set_has_header();
    request_content_.header_ = header;
  }
  // @@protoc_insertion_point(field_set_allocated:rokid.open.AsrRequest.header)
}

// optional bytes voice = 2;
bool AsrRequest::has_voice() const {
  return request_content_case() == kVoice;
}
void AsrRequest::set_has_voice() {
  _oneof_case_[0] = kVoice;
}
void AsrRequest::clear_voice() {
  if (has_voice()) {
    request_content_.voice_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_request_content();
  }
}
const ::std::string& AsrRequest::voice() const {
  // @@protoc_insertion_point(field_get:rokid.open.AsrRequest.voice)
  if (has_voice()) {
    return request_content_.voice_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
void AsrRequest::set_voice(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:rokid.open.AsrRequest.voice)
  if (!has_voice()) {
    clear_request_content();
    set_has_voice();
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  request_content_.voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.AsrRequest.voice)
}
void AsrRequest::set_voice(const char* value) {
  if (!has_voice()) {
    clear_request_content();
    set_has_voice();
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  request_content_.voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.AsrRequest.voice)
}
void AsrRequest::set_voice(const void* value, size_t size) {
  if (!has_voice()) {
    clear_request_content();
    set_has_voice();
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  request_content_.voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.AsrRequest.voice)
}
::std::string* AsrRequest::mutable_voice() {
  if (!has_voice()) {
    clear_request_content();
    set_has_voice();
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:rokid.open.AsrRequest.voice)
  return request_content_.voice_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* AsrRequest::release_voice() {
  // @@protoc_insertion_point(field_release:rokid.open.AsrRequest.voice)
  if (has_voice()) {
    clear_has_request_content();
    return request_content_.voice_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
void AsrRequest::set_allocated_voice(::std::string* voice) {
  if (!has_voice()) {
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_request_content();
  if (voice != NULL) {
    set_has_voice();
    request_content_.voice_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        voice);
  }
  // @@protoc_insertion_point(field_set_allocated:rokid.open.AsrRequest.voice)
}

bool AsrRequest::has_request_content() const {
  return request_content_case() != REQUEST_CONTENT_NOT_SET;
}
void AsrRequest::clear_has_request_content() {
  _oneof_case_[0] = REQUEST_CONTENT_NOT_SET;
}
AsrRequest::RequestContentCase AsrRequest::request_content_case() const {
  return AsrRequest::RequestContentCase(_oneof_case_[0]);
}
inline const AsrRequest* AsrRequest::internal_default_instance() {
  return &AsrRequest_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AsrHeader::kIdFieldNumber;
const int AsrHeader::kLangFieldNumber;
const int AsrHeader::kCodecFieldNumber;
const int AsrHeader::kVtFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AsrHeader::AsrHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_speech_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:rokid.open.AsrHeader)
}

void AsrHeader::InitAsDefaultInstance() {
}

AsrHeader::AsrHeader(const AsrHeader& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:rokid.open.AsrHeader)
}

void AsrHeader::SharedCtor() {
  lang_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  codec_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vt_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_ = 0;
  _cached_size_ = 0;
}

AsrHeader::~AsrHeader() {
  // @@protoc_insertion_point(destructor:rokid.open.AsrHeader)
  SharedDtor();
}

void AsrHeader::SharedDtor() {
  lang_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  codec_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vt_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void AsrHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AsrHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AsrHeader_descriptor_;
}

const AsrHeader& AsrHeader::default_instance() {
  protobuf_InitDefaults_speech_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<AsrHeader> AsrHeader_default_instance_;

AsrHeader* AsrHeader::New(::google::protobuf::Arena* arena) const {
  AsrHeader* n = new AsrHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AsrHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:rokid.open.AsrHeader)
  id_ = 0;
  lang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  codec_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool AsrHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:rokid.open.AsrHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (tag == 8) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_lang;
        break;
      }

      // optional string lang = 2;
      case 2: {
        if (tag == 18) {
         parse_lang:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_lang()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->lang().data(), this->lang().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.AsrHeader.lang"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_codec;
        break;
      }

      // optional string codec = 3;
      case 3: {
        if (tag == 26) {
         parse_codec:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_codec()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->codec().data(), this->codec().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.AsrHeader.codec"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_vt;
        break;
      }

      // optional string vt = 4;
      case 4: {
        if (tag == 34) {
         parse_vt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vt()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->vt().data(), this->vt().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.AsrHeader.vt"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:rokid.open.AsrHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:rokid.open.AsrHeader)
  return false;
#undef DO_
}

void AsrHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:rokid.open.AsrHeader)
  // optional int32 id = 1;
  if (this->id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional string lang = 2;
  if (this->lang().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->lang().data(), this->lang().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.AsrHeader.lang");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->lang(), output);
  }

  // optional string codec = 3;
  if (this->codec().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->codec().data(), this->codec().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.AsrHeader.codec");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->codec(), output);
  }

  // optional string vt = 4;
  if (this->vt().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vt().data(), this->vt().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.AsrHeader.vt");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->vt(), output);
  }

  // @@protoc_insertion_point(serialize_end:rokid.open.AsrHeader)
}

::google::protobuf::uint8* AsrHeader::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:rokid.open.AsrHeader)
  // optional int32 id = 1;
  if (this->id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional string lang = 2;
  if (this->lang().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->lang().data(), this->lang().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.AsrHeader.lang");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->lang(), target);
  }

  // optional string codec = 3;
  if (this->codec().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->codec().data(), this->codec().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.AsrHeader.codec");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->codec(), target);
  }

  // optional string vt = 4;
  if (this->vt().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vt().data(), this->vt().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.AsrHeader.vt");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->vt(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:rokid.open.AsrHeader)
  return target;
}

size_t AsrHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rokid.open.AsrHeader)
  size_t total_size = 0;

  // optional int32 id = 1;
  if (this->id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());
  }

  // optional string lang = 2;
  if (this->lang().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->lang());
  }

  // optional string codec = 3;
  if (this->codec().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->codec());
  }

  // optional string vt = 4;
  if (this->vt().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->vt());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AsrHeader::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:rokid.open.AsrHeader)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const AsrHeader* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const AsrHeader>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:rokid.open.AsrHeader)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:rokid.open.AsrHeader)
    UnsafeMergeFrom(*source);
  }
}

void AsrHeader::MergeFrom(const AsrHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rokid.open.AsrHeader)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void AsrHeader::UnsafeMergeFrom(const AsrHeader& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.id() != 0) {
    set_id(from.id());
  }
  if (from.lang().size() > 0) {

    lang_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.lang_);
  }
  if (from.codec().size() > 0) {

    codec_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.codec_);
  }
  if (from.vt().size() > 0) {

    vt_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vt_);
  }
}

void AsrHeader::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:rokid.open.AsrHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AsrHeader::CopyFrom(const AsrHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rokid.open.AsrHeader)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool AsrHeader::IsInitialized() const {

  return true;
}

void AsrHeader::Swap(AsrHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AsrHeader::InternalSwap(AsrHeader* other) {
  std::swap(id_, other->id_);
  lang_.Swap(&other->lang_);
  codec_.Swap(&other->codec_);
  vt_.Swap(&other->vt_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AsrHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AsrHeader_descriptor_;
  metadata.reflection = AsrHeader_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AsrHeader

// optional int32 id = 1;
void AsrHeader::clear_id() {
  id_ = 0;
}
::google::protobuf::int32 AsrHeader::id() const {
  // @@protoc_insertion_point(field_get:rokid.open.AsrHeader.id)
  return id_;
}
void AsrHeader::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:rokid.open.AsrHeader.id)
}

// optional string lang = 2;
void AsrHeader::clear_lang() {
  lang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& AsrHeader::lang() const {
  // @@protoc_insertion_point(field_get:rokid.open.AsrHeader.lang)
  return lang_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void AsrHeader::set_lang(const ::std::string& value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.AsrHeader.lang)
}
void AsrHeader::set_lang(const char* value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.AsrHeader.lang)
}
void AsrHeader::set_lang(const char* value, size_t size) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.AsrHeader.lang)
}
::std::string* AsrHeader::mutable_lang() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.AsrHeader.lang)
  return lang_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* AsrHeader::release_lang() {
  // @@protoc_insertion_point(field_release:rokid.open.AsrHeader.lang)
  
  return lang_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void AsrHeader::set_allocated_lang(::std::string* lang) {
  if (lang != NULL) {
    
  } else {
    
  }
  lang_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lang);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.AsrHeader.lang)
}

// optional string codec = 3;
void AsrHeader::clear_codec() {
  codec_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& AsrHeader::codec() const {
  // @@protoc_insertion_point(field_get:rokid.open.AsrHeader.codec)
  return codec_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void AsrHeader::set_codec(const ::std::string& value) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.AsrHeader.codec)
}
void AsrHeader::set_codec(const char* value) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.AsrHeader.codec)
}
void AsrHeader::set_codec(const char* value, size_t size) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.AsrHeader.codec)
}
::std::string* AsrHeader::mutable_codec() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.AsrHeader.codec)
  return codec_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* AsrHeader::release_codec() {
  // @@protoc_insertion_point(field_release:rokid.open.AsrHeader.codec)
  
  return codec_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void AsrHeader::set_allocated_codec(::std::string* codec) {
  if (codec != NULL) {
    
  } else {
    
  }
  codec_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codec);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.AsrHeader.codec)
}

// optional string vt = 4;
void AsrHeader::clear_vt() {
  vt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& AsrHeader::vt() const {
  // @@protoc_insertion_point(field_get:rokid.open.AsrHeader.vt)
  return vt_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void AsrHeader::set_vt(const ::std::string& value) {
  
  vt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.AsrHeader.vt)
}
void AsrHeader::set_vt(const char* value) {
  
  vt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.AsrHeader.vt)
}
void AsrHeader::set_vt(const char* value, size_t size) {
  
  vt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.AsrHeader.vt)
}
::std::string* AsrHeader::mutable_vt() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.AsrHeader.vt)
  return vt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* AsrHeader::release_vt() {
  // @@protoc_insertion_point(field_release:rokid.open.AsrHeader.vt)
  
  return vt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void AsrHeader::set_allocated_vt(::std::string* vt) {
  if (vt != NULL) {
    
  } else {
    
  }
  vt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vt);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.AsrHeader.vt)
}

inline const AsrHeader* AsrHeader::internal_default_instance() {
  return &AsrHeader_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int AsrResponse::kAsrFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

AsrResponse::AsrResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_speech_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:rokid.open.AsrResponse)
}

void AsrResponse::InitAsDefaultInstance() {
}

AsrResponse::AsrResponse(const AsrResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:rokid.open.AsrResponse)
}

void AsrResponse::SharedCtor() {
  asr_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _cached_size_ = 0;
}

AsrResponse::~AsrResponse() {
  // @@protoc_insertion_point(destructor:rokid.open.AsrResponse)
  SharedDtor();
}

void AsrResponse::SharedDtor() {
  asr_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void AsrResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* AsrResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return AsrResponse_descriptor_;
}

const AsrResponse& AsrResponse::default_instance() {
  protobuf_InitDefaults_speech_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<AsrResponse> AsrResponse_default_instance_;

AsrResponse* AsrResponse::New(::google::protobuf::Arena* arena) const {
  AsrResponse* n = new AsrResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void AsrResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:rokid.open.AsrResponse)
  asr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool AsrResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:rokid.open.AsrResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string asr = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_asr()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->asr().data(), this->asr().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.AsrResponse.asr"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:rokid.open.AsrResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:rokid.open.AsrResponse)
  return false;
#undef DO_
}

void AsrResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:rokid.open.AsrResponse)
  // optional string asr = 1;
  if (this->asr().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->asr().data(), this->asr().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.AsrResponse.asr");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->asr(), output);
  }

  // @@protoc_insertion_point(serialize_end:rokid.open.AsrResponse)
}

::google::protobuf::uint8* AsrResponse::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:rokid.open.AsrResponse)
  // optional string asr = 1;
  if (this->asr().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->asr().data(), this->asr().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.AsrResponse.asr");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->asr(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:rokid.open.AsrResponse)
  return target;
}

size_t AsrResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rokid.open.AsrResponse)
  size_t total_size = 0;

  // optional string asr = 1;
  if (this->asr().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->asr());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void AsrResponse::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:rokid.open.AsrResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const AsrResponse* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const AsrResponse>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:rokid.open.AsrResponse)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:rokid.open.AsrResponse)
    UnsafeMergeFrom(*source);
  }
}

void AsrResponse::MergeFrom(const AsrResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rokid.open.AsrResponse)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void AsrResponse::UnsafeMergeFrom(const AsrResponse& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.asr().size() > 0) {

    asr_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.asr_);
  }
}

void AsrResponse::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:rokid.open.AsrResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void AsrResponse::CopyFrom(const AsrResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rokid.open.AsrResponse)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool AsrResponse::IsInitialized() const {

  return true;
}

void AsrResponse::Swap(AsrResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void AsrResponse::InternalSwap(AsrResponse* other) {
  asr_.Swap(&other->asr_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata AsrResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = AsrResponse_descriptor_;
  metadata.reflection = AsrResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// AsrResponse

// optional string asr = 1;
void AsrResponse::clear_asr() {
  asr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& AsrResponse::asr() const {
  // @@protoc_insertion_point(field_get:rokid.open.AsrResponse.asr)
  return asr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void AsrResponse::set_asr(const ::std::string& value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.AsrResponse.asr)
}
void AsrResponse::set_asr(const char* value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.AsrResponse.asr)
}
void AsrResponse::set_asr(const char* value, size_t size) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.AsrResponse.asr)
}
::std::string* AsrResponse::mutable_asr() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.AsrResponse.asr)
  return asr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* AsrResponse::release_asr() {
  // @@protoc_insertion_point(field_release:rokid.open.AsrResponse.asr)
  
  return asr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void AsrResponse::set_allocated_asr(::std::string* asr) {
  if (asr != NULL) {
    
  } else {
    
  }
  asr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asr);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.AsrResponse.asr)
}

inline const AsrResponse* AsrResponse::internal_default_instance() {
  return &AsrResponse_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NlpRequest::kHeaderFieldNumber;
const int NlpRequest::kAsrFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NlpRequest::NlpRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_speech_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:rokid.open.NlpRequest)
}

void NlpRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::rokid::open::NlpHeader*>(
      ::rokid::open::NlpHeader::internal_default_instance());
}

NlpRequest::NlpRequest(const NlpRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:rokid.open.NlpRequest)
}

void NlpRequest::SharedCtor() {
  asr_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  header_ = NULL;
  _cached_size_ = 0;
}

NlpRequest::~NlpRequest() {
  // @@protoc_insertion_point(destructor:rokid.open.NlpRequest)
  SharedDtor();
}

void NlpRequest::SharedDtor() {
  asr_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != &NlpRequest_default_instance_.get()) {
    delete header_;
  }
}

void NlpRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NlpRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NlpRequest_descriptor_;
}

const NlpRequest& NlpRequest::default_instance() {
  protobuf_InitDefaults_speech_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<NlpRequest> NlpRequest_default_instance_;

NlpRequest* NlpRequest::New(::google::protobuf::Arena* arena) const {
  NlpRequest* n = new NlpRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NlpRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:rokid.open.NlpRequest)
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
  asr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool NlpRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:rokid.open.NlpRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .rokid.open.NlpHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_asr;
        break;
      }

      // optional string asr = 2;
      case 2: {
        if (tag == 18) {
         parse_asr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_asr()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->asr().data(), this->asr().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.NlpRequest.asr"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:rokid.open.NlpRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:rokid.open.NlpRequest)
  return false;
#undef DO_
}

void NlpRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:rokid.open.NlpRequest)
  // optional .rokid.open.NlpHeader header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional string asr = 2;
  if (this->asr().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->asr().data(), this->asr().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.NlpRequest.asr");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->asr(), output);
  }

  // @@protoc_insertion_point(serialize_end:rokid.open.NlpRequest)
}

::google::protobuf::uint8* NlpRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:rokid.open.NlpRequest)
  // optional .rokid.open.NlpHeader header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, false, target);
  }

  // optional string asr = 2;
  if (this->asr().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->asr().data(), this->asr().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.NlpRequest.asr");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->asr(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:rokid.open.NlpRequest)
  return target;
}

size_t NlpRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rokid.open.NlpRequest)
  size_t total_size = 0;

  // optional .rokid.open.NlpHeader header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // optional string asr = 2;
  if (this->asr().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->asr());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NlpRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:rokid.open.NlpRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const NlpRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const NlpRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:rokid.open.NlpRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:rokid.open.NlpRequest)
    UnsafeMergeFrom(*source);
  }
}

void NlpRequest::MergeFrom(const NlpRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rokid.open.NlpRequest)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void NlpRequest::UnsafeMergeFrom(const NlpRequest& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.has_header()) {
    mutable_header()->::rokid::open::NlpHeader::MergeFrom(from.header());
  }
  if (from.asr().size() > 0) {

    asr_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.asr_);
  }
}

void NlpRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:rokid.open.NlpRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NlpRequest::CopyFrom(const NlpRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rokid.open.NlpRequest)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool NlpRequest::IsInitialized() const {

  return true;
}

void NlpRequest::Swap(NlpRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NlpRequest::InternalSwap(NlpRequest* other) {
  std::swap(header_, other->header_);
  asr_.Swap(&other->asr_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NlpRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NlpRequest_descriptor_;
  metadata.reflection = NlpRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NlpRequest

// optional .rokid.open.NlpHeader header = 1;
bool NlpRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void NlpRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::rokid::open::NlpHeader& NlpRequest::header() const {
  // @@protoc_insertion_point(field_get:rokid.open.NlpRequest.header)
  return header_ != NULL ? *header_
                         : *::rokid::open::NlpHeader::internal_default_instance();
}
::rokid::open::NlpHeader* NlpRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::rokid::open::NlpHeader;
  }
  // @@protoc_insertion_point(field_mutable:rokid.open.NlpRequest.header)
  return header_;
}
::rokid::open::NlpHeader* NlpRequest::release_header() {
  // @@protoc_insertion_point(field_release:rokid.open.NlpRequest.header)
  
  ::rokid::open::NlpHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void NlpRequest::set_allocated_header(::rokid::open::NlpHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rokid.open.NlpRequest.header)
}

// optional string asr = 2;
void NlpRequest::clear_asr() {
  asr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& NlpRequest::asr() const {
  // @@protoc_insertion_point(field_get:rokid.open.NlpRequest.asr)
  return asr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void NlpRequest::set_asr(const ::std::string& value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.NlpRequest.asr)
}
void NlpRequest::set_asr(const char* value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.NlpRequest.asr)
}
void NlpRequest::set_asr(const char* value, size_t size) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.NlpRequest.asr)
}
::std::string* NlpRequest::mutable_asr() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.NlpRequest.asr)
  return asr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* NlpRequest::release_asr() {
  // @@protoc_insertion_point(field_release:rokid.open.NlpRequest.asr)
  
  return asr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void NlpRequest::set_allocated_asr(::std::string* asr) {
  if (asr != NULL) {
    
  } else {
    
  }
  asr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asr);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.NlpRequest.asr)
}

inline const NlpRequest* NlpRequest::internal_default_instance() {
  return &NlpRequest_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NlpHeader::kIdFieldNumber;
const int NlpHeader::kLangFieldNumber;
const int NlpHeader::kCdomainFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NlpHeader::NlpHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_speech_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:rokid.open.NlpHeader)
}

void NlpHeader::InitAsDefaultInstance() {
}

NlpHeader::NlpHeader(const NlpHeader& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:rokid.open.NlpHeader)
}

void NlpHeader::SharedCtor() {
  lang_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cdomain_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_ = 0;
  _cached_size_ = 0;
}

NlpHeader::~NlpHeader() {
  // @@protoc_insertion_point(destructor:rokid.open.NlpHeader)
  SharedDtor();
}

void NlpHeader::SharedDtor() {
  lang_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cdomain_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NlpHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NlpHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NlpHeader_descriptor_;
}

const NlpHeader& NlpHeader::default_instance() {
  protobuf_InitDefaults_speech_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<NlpHeader> NlpHeader_default_instance_;

NlpHeader* NlpHeader::New(::google::protobuf::Arena* arena) const {
  NlpHeader* n = new NlpHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NlpHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:rokid.open.NlpHeader)
  id_ = 0;
  lang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cdomain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool NlpHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:rokid.open.NlpHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (tag == 8) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_lang;
        break;
      }

      // optional string lang = 2;
      case 2: {
        if (tag == 18) {
         parse_lang:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_lang()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->lang().data(), this->lang().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.NlpHeader.lang"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_cdomain;
        break;
      }

      // optional string cdomain = 3;
      case 3: {
        if (tag == 26) {
         parse_cdomain:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cdomain()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->cdomain().data(), this->cdomain().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.NlpHeader.cdomain"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:rokid.open.NlpHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:rokid.open.NlpHeader)
  return false;
#undef DO_
}

void NlpHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:rokid.open.NlpHeader)
  // optional int32 id = 1;
  if (this->id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional string lang = 2;
  if (this->lang().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->lang().data(), this->lang().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.NlpHeader.lang");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->lang(), output);
  }

  // optional string cdomain = 3;
  if (this->cdomain().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->cdomain().data(), this->cdomain().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.NlpHeader.cdomain");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->cdomain(), output);
  }

  // @@protoc_insertion_point(serialize_end:rokid.open.NlpHeader)
}

::google::protobuf::uint8* NlpHeader::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:rokid.open.NlpHeader)
  // optional int32 id = 1;
  if (this->id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional string lang = 2;
  if (this->lang().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->lang().data(), this->lang().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.NlpHeader.lang");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->lang(), target);
  }

  // optional string cdomain = 3;
  if (this->cdomain().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->cdomain().data(), this->cdomain().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.NlpHeader.cdomain");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->cdomain(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:rokid.open.NlpHeader)
  return target;
}

size_t NlpHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rokid.open.NlpHeader)
  size_t total_size = 0;

  // optional int32 id = 1;
  if (this->id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());
  }

  // optional string lang = 2;
  if (this->lang().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->lang());
  }

  // optional string cdomain = 3;
  if (this->cdomain().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->cdomain());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NlpHeader::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:rokid.open.NlpHeader)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const NlpHeader* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const NlpHeader>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:rokid.open.NlpHeader)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:rokid.open.NlpHeader)
    UnsafeMergeFrom(*source);
  }
}

void NlpHeader::MergeFrom(const NlpHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rokid.open.NlpHeader)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void NlpHeader::UnsafeMergeFrom(const NlpHeader& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.id() != 0) {
    set_id(from.id());
  }
  if (from.lang().size() > 0) {

    lang_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.lang_);
  }
  if (from.cdomain().size() > 0) {

    cdomain_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.cdomain_);
  }
}

void NlpHeader::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:rokid.open.NlpHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NlpHeader::CopyFrom(const NlpHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rokid.open.NlpHeader)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool NlpHeader::IsInitialized() const {

  return true;
}

void NlpHeader::Swap(NlpHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NlpHeader::InternalSwap(NlpHeader* other) {
  std::swap(id_, other->id_);
  lang_.Swap(&other->lang_);
  cdomain_.Swap(&other->cdomain_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NlpHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NlpHeader_descriptor_;
  metadata.reflection = NlpHeader_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NlpHeader

// optional int32 id = 1;
void NlpHeader::clear_id() {
  id_ = 0;
}
::google::protobuf::int32 NlpHeader::id() const {
  // @@protoc_insertion_point(field_get:rokid.open.NlpHeader.id)
  return id_;
}
void NlpHeader::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:rokid.open.NlpHeader.id)
}

// optional string lang = 2;
void NlpHeader::clear_lang() {
  lang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& NlpHeader::lang() const {
  // @@protoc_insertion_point(field_get:rokid.open.NlpHeader.lang)
  return lang_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void NlpHeader::set_lang(const ::std::string& value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.NlpHeader.lang)
}
void NlpHeader::set_lang(const char* value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.NlpHeader.lang)
}
void NlpHeader::set_lang(const char* value, size_t size) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.NlpHeader.lang)
}
::std::string* NlpHeader::mutable_lang() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.NlpHeader.lang)
  return lang_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* NlpHeader::release_lang() {
  // @@protoc_insertion_point(field_release:rokid.open.NlpHeader.lang)
  
  return lang_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void NlpHeader::set_allocated_lang(::std::string* lang) {
  if (lang != NULL) {
    
  } else {
    
  }
  lang_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lang);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.NlpHeader.lang)
}

// optional string cdomain = 3;
void NlpHeader::clear_cdomain() {
  cdomain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& NlpHeader::cdomain() const {
  // @@protoc_insertion_point(field_get:rokid.open.NlpHeader.cdomain)
  return cdomain_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void NlpHeader::set_cdomain(const ::std::string& value) {
  
  cdomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.NlpHeader.cdomain)
}
void NlpHeader::set_cdomain(const char* value) {
  
  cdomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.NlpHeader.cdomain)
}
void NlpHeader::set_cdomain(const char* value, size_t size) {
  
  cdomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.NlpHeader.cdomain)
}
::std::string* NlpHeader::mutable_cdomain() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.NlpHeader.cdomain)
  return cdomain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* NlpHeader::release_cdomain() {
  // @@protoc_insertion_point(field_release:rokid.open.NlpHeader.cdomain)
  
  return cdomain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void NlpHeader::set_allocated_cdomain(::std::string* cdomain) {
  if (cdomain != NULL) {
    
  } else {
    
  }
  cdomain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cdomain);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.NlpHeader.cdomain)
}

inline const NlpHeader* NlpHeader::internal_default_instance() {
  return &NlpHeader_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int NlpResponse::kNlpFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

NlpResponse::NlpResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_speech_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:rokid.open.NlpResponse)
}

void NlpResponse::InitAsDefaultInstance() {
}

NlpResponse::NlpResponse(const NlpResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:rokid.open.NlpResponse)
}

void NlpResponse::SharedCtor() {
  nlp_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _cached_size_ = 0;
}

NlpResponse::~NlpResponse() {
  // @@protoc_insertion_point(destructor:rokid.open.NlpResponse)
  SharedDtor();
}

void NlpResponse::SharedDtor() {
  nlp_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void NlpResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* NlpResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return NlpResponse_descriptor_;
}

const NlpResponse& NlpResponse::default_instance() {
  protobuf_InitDefaults_speech_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<NlpResponse> NlpResponse_default_instance_;

NlpResponse* NlpResponse::New(::google::protobuf::Arena* arena) const {
  NlpResponse* n = new NlpResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void NlpResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:rokid.open.NlpResponse)
  nlp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool NlpResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:rokid.open.NlpResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string nlp = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nlp()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->nlp().data(), this->nlp().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.NlpResponse.nlp"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:rokid.open.NlpResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:rokid.open.NlpResponse)
  return false;
#undef DO_
}

void NlpResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:rokid.open.NlpResponse)
  // optional string nlp = 1;
  if (this->nlp().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->nlp().data(), this->nlp().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.NlpResponse.nlp");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->nlp(), output);
  }

  // @@protoc_insertion_point(serialize_end:rokid.open.NlpResponse)
}

::google::protobuf::uint8* NlpResponse::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:rokid.open.NlpResponse)
  // optional string nlp = 1;
  if (this->nlp().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->nlp().data(), this->nlp().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.NlpResponse.nlp");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->nlp(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:rokid.open.NlpResponse)
  return target;
}

size_t NlpResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rokid.open.NlpResponse)
  size_t total_size = 0;

  // optional string nlp = 1;
  if (this->nlp().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->nlp());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void NlpResponse::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:rokid.open.NlpResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const NlpResponse* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const NlpResponse>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:rokid.open.NlpResponse)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:rokid.open.NlpResponse)
    UnsafeMergeFrom(*source);
  }
}

void NlpResponse::MergeFrom(const NlpResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rokid.open.NlpResponse)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void NlpResponse::UnsafeMergeFrom(const NlpResponse& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.nlp().size() > 0) {

    nlp_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nlp_);
  }
}

void NlpResponse::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:rokid.open.NlpResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void NlpResponse::CopyFrom(const NlpResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rokid.open.NlpResponse)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool NlpResponse::IsInitialized() const {

  return true;
}

void NlpResponse::Swap(NlpResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void NlpResponse::InternalSwap(NlpResponse* other) {
  nlp_.Swap(&other->nlp_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata NlpResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = NlpResponse_descriptor_;
  metadata.reflection = NlpResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// NlpResponse

// optional string nlp = 1;
void NlpResponse::clear_nlp() {
  nlp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& NlpResponse::nlp() const {
  // @@protoc_insertion_point(field_get:rokid.open.NlpResponse.nlp)
  return nlp_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void NlpResponse::set_nlp(const ::std::string& value) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.NlpResponse.nlp)
}
void NlpResponse::set_nlp(const char* value) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.NlpResponse.nlp)
}
void NlpResponse::set_nlp(const char* value, size_t size) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.NlpResponse.nlp)
}
::std::string* NlpResponse::mutable_nlp() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.NlpResponse.nlp)
  return nlp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* NlpResponse::release_nlp() {
  // @@protoc_insertion_point(field_release:rokid.open.NlpResponse.nlp)
  
  return nlp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void NlpResponse::set_allocated_nlp(::std::string* nlp) {
  if (nlp != NULL) {
    
  } else {
    
  }
  nlp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nlp);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.NlpResponse.nlp)
}

inline const NlpResponse* NlpResponse::internal_default_instance() {
  return &NlpResponse_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TtsRequest::kHeaderFieldNumber;
const int TtsRequest::kTextFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TtsRequest::TtsRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_speech_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:rokid.open.TtsRequest)
}

void TtsRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::rokid::open::TtsHeader*>(
      ::rokid::open::TtsHeader::internal_default_instance());
}

TtsRequest::TtsRequest(const TtsRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:rokid.open.TtsRequest)
}

void TtsRequest::SharedCtor() {
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  header_ = NULL;
  _cached_size_ = 0;
}

TtsRequest::~TtsRequest() {
  // @@protoc_insertion_point(destructor:rokid.open.TtsRequest)
  SharedDtor();
}

void TtsRequest::SharedDtor() {
  text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != &TtsRequest_default_instance_.get()) {
    delete header_;
  }
}

void TtsRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TtsRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TtsRequest_descriptor_;
}

const TtsRequest& TtsRequest::default_instance() {
  protobuf_InitDefaults_speech_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<TtsRequest> TtsRequest_default_instance_;

TtsRequest* TtsRequest::New(::google::protobuf::Arena* arena) const {
  TtsRequest* n = new TtsRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TtsRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:rokid.open.TtsRequest)
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TtsRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:rokid.open.TtsRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .rokid.open.TtsHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_text;
        break;
      }

      // optional string text = 2;
      case 2: {
        if (tag == 18) {
         parse_text:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.TtsRequest.text"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:rokid.open.TtsRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:rokid.open.TtsRequest)
  return false;
#undef DO_
}

void TtsRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:rokid.open.TtsRequest)
  // optional .rokid.open.TtsHeader header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional string text = 2;
  if (this->text().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.TtsRequest.text");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->text(), output);
  }

  // @@protoc_insertion_point(serialize_end:rokid.open.TtsRequest)
}

::google::protobuf::uint8* TtsRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:rokid.open.TtsRequest)
  // optional .rokid.open.TtsHeader header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, false, target);
  }

  // optional string text = 2;
  if (this->text().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.TtsRequest.text");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->text(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:rokid.open.TtsRequest)
  return target;
}

size_t TtsRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rokid.open.TtsRequest)
  size_t total_size = 0;

  // optional .rokid.open.TtsHeader header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // optional string text = 2;
  if (this->text().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->text());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TtsRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:rokid.open.TtsRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TtsRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TtsRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:rokid.open.TtsRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:rokid.open.TtsRequest)
    UnsafeMergeFrom(*source);
  }
}

void TtsRequest::MergeFrom(const TtsRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rokid.open.TtsRequest)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void TtsRequest::UnsafeMergeFrom(const TtsRequest& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.has_header()) {
    mutable_header()->::rokid::open::TtsHeader::MergeFrom(from.header());
  }
  if (from.text().size() > 0) {

    text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
  }
}

void TtsRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:rokid.open.TtsRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TtsRequest::CopyFrom(const TtsRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rokid.open.TtsRequest)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool TtsRequest::IsInitialized() const {

  return true;
}

void TtsRequest::Swap(TtsRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TtsRequest::InternalSwap(TtsRequest* other) {
  std::swap(header_, other->header_);
  text_.Swap(&other->text_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TtsRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TtsRequest_descriptor_;
  metadata.reflection = TtsRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TtsRequest

// optional .rokid.open.TtsHeader header = 1;
bool TtsRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void TtsRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::rokid::open::TtsHeader& TtsRequest::header() const {
  // @@protoc_insertion_point(field_get:rokid.open.TtsRequest.header)
  return header_ != NULL ? *header_
                         : *::rokid::open::TtsHeader::internal_default_instance();
}
::rokid::open::TtsHeader* TtsRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::rokid::open::TtsHeader;
  }
  // @@protoc_insertion_point(field_mutable:rokid.open.TtsRequest.header)
  return header_;
}
::rokid::open::TtsHeader* TtsRequest::release_header() {
  // @@protoc_insertion_point(field_release:rokid.open.TtsRequest.header)
  
  ::rokid::open::TtsHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void TtsRequest::set_allocated_header(::rokid::open::TtsHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TtsRequest.header)
}

// optional string text = 2;
void TtsRequest::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& TtsRequest::text() const {
  // @@protoc_insertion_point(field_get:rokid.open.TtsRequest.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TtsRequest::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TtsRequest.text)
}
void TtsRequest::set_text(const char* value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TtsRequest.text)
}
void TtsRequest::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TtsRequest.text)
}
::std::string* TtsRequest::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TtsRequest.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TtsRequest::release_text() {
  // @@protoc_insertion_point(field_release:rokid.open.TtsRequest.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TtsRequest::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TtsRequest.text)
}

inline const TtsRequest* TtsRequest::internal_default_instance() {
  return &TtsRequest_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TtsHeader::kIdFieldNumber;
const int TtsHeader::kDeclaimerFieldNumber;
const int TtsHeader::kCodecFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TtsHeader::TtsHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_speech_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:rokid.open.TtsHeader)
}

void TtsHeader::InitAsDefaultInstance() {
}

TtsHeader::TtsHeader(const TtsHeader& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:rokid.open.TtsHeader)
}

void TtsHeader::SharedCtor() {
  declaimer_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  codec_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_ = 0;
  _cached_size_ = 0;
}

TtsHeader::~TtsHeader() {
  // @@protoc_insertion_point(destructor:rokid.open.TtsHeader)
  SharedDtor();
}

void TtsHeader::SharedDtor() {
  declaimer_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  codec_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TtsHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TtsHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TtsHeader_descriptor_;
}

const TtsHeader& TtsHeader::default_instance() {
  protobuf_InitDefaults_speech_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<TtsHeader> TtsHeader_default_instance_;

TtsHeader* TtsHeader::New(::google::protobuf::Arena* arena) const {
  TtsHeader* n = new TtsHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TtsHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:rokid.open.TtsHeader)
  id_ = 0;
  declaimer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  codec_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TtsHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:rokid.open.TtsHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (tag == 8) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_declaimer;
        break;
      }

      // optional string declaimer = 2;
      case 2: {
        if (tag == 18) {
         parse_declaimer:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_declaimer()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->declaimer().data(), this->declaimer().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.TtsHeader.declaimer"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_codec;
        break;
      }

      // optional string codec = 3;
      case 3: {
        if (tag == 26) {
         parse_codec:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_codec()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->codec().data(), this->codec().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.TtsHeader.codec"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:rokid.open.TtsHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:rokid.open.TtsHeader)
  return false;
#undef DO_
}

void TtsHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:rokid.open.TtsHeader)
  // optional int32 id = 1;
  if (this->id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional string declaimer = 2;
  if (this->declaimer().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->declaimer().data(), this->declaimer().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.TtsHeader.declaimer");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->declaimer(), output);
  }

  // optional string codec = 3;
  if (this->codec().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->codec().data(), this->codec().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.TtsHeader.codec");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->codec(), output);
  }

  // @@protoc_insertion_point(serialize_end:rokid.open.TtsHeader)
}

::google::protobuf::uint8* TtsHeader::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:rokid.open.TtsHeader)
  // optional int32 id = 1;
  if (this->id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional string declaimer = 2;
  if (this->declaimer().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->declaimer().data(), this->declaimer().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.TtsHeader.declaimer");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->declaimer(), target);
  }

  // optional string codec = 3;
  if (this->codec().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->codec().data(), this->codec().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.TtsHeader.codec");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->codec(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:rokid.open.TtsHeader)
  return target;
}

size_t TtsHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rokid.open.TtsHeader)
  size_t total_size = 0;

  // optional int32 id = 1;
  if (this->id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());
  }

  // optional string declaimer = 2;
  if (this->declaimer().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->declaimer());
  }

  // optional string codec = 3;
  if (this->codec().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->codec());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TtsHeader::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:rokid.open.TtsHeader)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TtsHeader* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TtsHeader>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:rokid.open.TtsHeader)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:rokid.open.TtsHeader)
    UnsafeMergeFrom(*source);
  }
}

void TtsHeader::MergeFrom(const TtsHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rokid.open.TtsHeader)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void TtsHeader::UnsafeMergeFrom(const TtsHeader& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.id() != 0) {
    set_id(from.id());
  }
  if (from.declaimer().size() > 0) {

    declaimer_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.declaimer_);
  }
  if (from.codec().size() > 0) {

    codec_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.codec_);
  }
}

void TtsHeader::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:rokid.open.TtsHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TtsHeader::CopyFrom(const TtsHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rokid.open.TtsHeader)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool TtsHeader::IsInitialized() const {

  return true;
}

void TtsHeader::Swap(TtsHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TtsHeader::InternalSwap(TtsHeader* other) {
  std::swap(id_, other->id_);
  declaimer_.Swap(&other->declaimer_);
  codec_.Swap(&other->codec_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TtsHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TtsHeader_descriptor_;
  metadata.reflection = TtsHeader_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TtsHeader

// optional int32 id = 1;
void TtsHeader::clear_id() {
  id_ = 0;
}
::google::protobuf::int32 TtsHeader::id() const {
  // @@protoc_insertion_point(field_get:rokid.open.TtsHeader.id)
  return id_;
}
void TtsHeader::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:rokid.open.TtsHeader.id)
}

// optional string declaimer = 2;
void TtsHeader::clear_declaimer() {
  declaimer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& TtsHeader::declaimer() const {
  // @@protoc_insertion_point(field_get:rokid.open.TtsHeader.declaimer)
  return declaimer_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TtsHeader::set_declaimer(const ::std::string& value) {
  
  declaimer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TtsHeader.declaimer)
}
void TtsHeader::set_declaimer(const char* value) {
  
  declaimer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TtsHeader.declaimer)
}
void TtsHeader::set_declaimer(const char* value, size_t size) {
  
  declaimer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TtsHeader.declaimer)
}
::std::string* TtsHeader::mutable_declaimer() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TtsHeader.declaimer)
  return declaimer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TtsHeader::release_declaimer() {
  // @@protoc_insertion_point(field_release:rokid.open.TtsHeader.declaimer)
  
  return declaimer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TtsHeader::set_allocated_declaimer(::std::string* declaimer) {
  if (declaimer != NULL) {
    
  } else {
    
  }
  declaimer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), declaimer);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TtsHeader.declaimer)
}

// optional string codec = 3;
void TtsHeader::clear_codec() {
  codec_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& TtsHeader::codec() const {
  // @@protoc_insertion_point(field_get:rokid.open.TtsHeader.codec)
  return codec_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TtsHeader::set_codec(const ::std::string& value) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TtsHeader.codec)
}
void TtsHeader::set_codec(const char* value) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TtsHeader.codec)
}
void TtsHeader::set_codec(const char* value, size_t size) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TtsHeader.codec)
}
::std::string* TtsHeader::mutable_codec() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TtsHeader.codec)
  return codec_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TtsHeader::release_codec() {
  // @@protoc_insertion_point(field_release:rokid.open.TtsHeader.codec)
  
  return codec_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TtsHeader::set_allocated_codec(::std::string* codec) {
  if (codec != NULL) {
    
  } else {
    
  }
  codec_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codec);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TtsHeader.codec)
}

inline const TtsHeader* TtsHeader::internal_default_instance() {
  return &TtsHeader_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TtsResponse::kTextFieldNumber;
const int TtsResponse::kVoiceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TtsResponse::TtsResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_speech_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:rokid.open.TtsResponse)
}

void TtsResponse::InitAsDefaultInstance() {
}

TtsResponse::TtsResponse(const TtsResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:rokid.open.TtsResponse)
}

void TtsResponse::SharedCtor() {
  text_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _cached_size_ = 0;
}

TtsResponse::~TtsResponse() {
  // @@protoc_insertion_point(destructor:rokid.open.TtsResponse)
  SharedDtor();
}

void TtsResponse::SharedDtor() {
  text_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  voice_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TtsResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TtsResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TtsResponse_descriptor_;
}

const TtsResponse& TtsResponse::default_instance() {
  protobuf_InitDefaults_speech_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<TtsResponse> TtsResponse_default_instance_;

TtsResponse* TtsResponse::New(::google::protobuf::Arena* arena) const {
  TtsResponse* n = new TtsResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TtsResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:rokid.open.TtsResponse)
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  voice_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TtsResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:rokid.open.TtsResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string text = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_text()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->text().data(), this->text().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.TtsResponse.text"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_voice;
        break;
      }

      // optional bytes voice = 2;
      case 2: {
        if (tag == 18) {
         parse_voice:
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_voice()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:rokid.open.TtsResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:rokid.open.TtsResponse)
  return false;
#undef DO_
}

void TtsResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:rokid.open.TtsResponse)
  // optional string text = 1;
  if (this->text().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.TtsResponse.text");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->text(), output);
  }

  // optional bytes voice = 2;
  if (this->voice().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->voice(), output);
  }

  // @@protoc_insertion_point(serialize_end:rokid.open.TtsResponse)
}

::google::protobuf::uint8* TtsResponse::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:rokid.open.TtsResponse)
  // optional string text = 1;
  if (this->text().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->text().data(), this->text().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.TtsResponse.text");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->text(), target);
  }

  // optional bytes voice = 2;
  if (this->voice().size() > 0) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->voice(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:rokid.open.TtsResponse)
  return target;
}

size_t TtsResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rokid.open.TtsResponse)
  size_t total_size = 0;

  // optional string text = 1;
  if (this->text().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->text());
  }

  // optional bytes voice = 2;
  if (this->voice().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::BytesSize(
        this->voice());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TtsResponse::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:rokid.open.TtsResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TtsResponse* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TtsResponse>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:rokid.open.TtsResponse)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:rokid.open.TtsResponse)
    UnsafeMergeFrom(*source);
  }
}

void TtsResponse::MergeFrom(const TtsResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rokid.open.TtsResponse)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void TtsResponse::UnsafeMergeFrom(const TtsResponse& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.text().size() > 0) {

    text_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.text_);
  }
  if (from.voice().size() > 0) {

    voice_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.voice_);
  }
}

void TtsResponse::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:rokid.open.TtsResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TtsResponse::CopyFrom(const TtsResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rokid.open.TtsResponse)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool TtsResponse::IsInitialized() const {

  return true;
}

void TtsResponse::Swap(TtsResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TtsResponse::InternalSwap(TtsResponse* other) {
  text_.Swap(&other->text_);
  voice_.Swap(&other->voice_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TtsResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TtsResponse_descriptor_;
  metadata.reflection = TtsResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TtsResponse

// optional string text = 1;
void TtsResponse::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& TtsResponse::text() const {
  // @@protoc_insertion_point(field_get:rokid.open.TtsResponse.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TtsResponse::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TtsResponse.text)
}
void TtsResponse::set_text(const char* value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TtsResponse.text)
}
void TtsResponse::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TtsResponse.text)
}
::std::string* TtsResponse::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TtsResponse.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TtsResponse::release_text() {
  // @@protoc_insertion_point(field_release:rokid.open.TtsResponse.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TtsResponse::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TtsResponse.text)
}

// optional bytes voice = 2;
void TtsResponse::clear_voice() {
  voice_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& TtsResponse::voice() const {
  // @@protoc_insertion_point(field_get:rokid.open.TtsResponse.voice)
  return voice_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TtsResponse::set_voice(const ::std::string& value) {
  
  voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TtsResponse.voice)
}
void TtsResponse::set_voice(const char* value) {
  
  voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TtsResponse.voice)
}
void TtsResponse::set_voice(const void* value, size_t size) {
  
  voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TtsResponse.voice)
}
::std::string* TtsResponse::mutable_voice() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TtsResponse.voice)
  return voice_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TtsResponse::release_voice() {
  // @@protoc_insertion_point(field_release:rokid.open.TtsResponse.voice)
  
  return voice_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TtsResponse::set_allocated_voice(::std::string* voice) {
  if (voice != NULL) {
    
  } else {
    
  }
  voice_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), voice);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TtsResponse.voice)
}

inline const TtsResponse* TtsResponse::internal_default_instance() {
  return &TtsResponse_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VoiceSpeechRequest::kHeaderFieldNumber;
const int VoiceSpeechRequest::kVoiceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VoiceSpeechRequest::VoiceSpeechRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_speech_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:rokid.open.VoiceSpeechRequest)
}

void VoiceSpeechRequest::InitAsDefaultInstance() {
  VoiceSpeechRequest_default_oneof_instance_->header_ = const_cast< ::rokid::open::SpeechHeader*>(
      ::rokid::open::SpeechHeader::internal_default_instance());
  VoiceSpeechRequest_default_oneof_instance_->voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

VoiceSpeechRequest::VoiceSpeechRequest(const VoiceSpeechRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:rokid.open.VoiceSpeechRequest)
}

void VoiceSpeechRequest::SharedCtor() {
  clear_has_request_content();
  _cached_size_ = 0;
}

VoiceSpeechRequest::~VoiceSpeechRequest() {
  // @@protoc_insertion_point(destructor:rokid.open.VoiceSpeechRequest)
  SharedDtor();
}

void VoiceSpeechRequest::SharedDtor() {
  if (has_request_content()) {
    clear_request_content();
  }
}

void VoiceSpeechRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VoiceSpeechRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VoiceSpeechRequest_descriptor_;
}

const VoiceSpeechRequest& VoiceSpeechRequest::default_instance() {
  protobuf_InitDefaults_speech_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<VoiceSpeechRequest> VoiceSpeechRequest_default_instance_;

VoiceSpeechRequest* VoiceSpeechRequest::New(::google::protobuf::Arena* arena) const {
  VoiceSpeechRequest* n = new VoiceSpeechRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void VoiceSpeechRequest::clear_request_content() {
// @@protoc_insertion_point(one_of_clear_start:rokid.open.VoiceSpeechRequest)
  switch (request_content_case()) {
    case kHeader: {
      delete request_content_.header_;
      break;
    }
    case kVoice: {
      request_content_.voice_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
      break;
    }
    case REQUEST_CONTENT_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = REQUEST_CONTENT_NOT_SET;
}


void VoiceSpeechRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:rokid.open.VoiceSpeechRequest)
  clear_request_content();
}

bool VoiceSpeechRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:rokid.open.VoiceSpeechRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .rokid.open.SpeechHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        goto after_voice;
        break;
      }

      // optional bytes voice = 2;
      case 2: {
        if (tag == 18) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadBytes(
                input, this->mutable_voice()));
        } else {
          goto handle_unusual;
        }
       after_voice:
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:rokid.open.VoiceSpeechRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:rokid.open.VoiceSpeechRequest)
  return false;
#undef DO_
}

void VoiceSpeechRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:rokid.open.VoiceSpeechRequest)
  // optional .rokid.open.SpeechHeader header = 1;
  if (has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *request_content_.header_, output);
  }

  // optional bytes voice = 2;
  if (has_voice()) {
    ::google::protobuf::internal::WireFormatLite::WriteBytesMaybeAliased(
      2, this->voice(), output);
  }

  // @@protoc_insertion_point(serialize_end:rokid.open.VoiceSpeechRequest)
}

::google::protobuf::uint8* VoiceSpeechRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:rokid.open.VoiceSpeechRequest)
  // optional .rokid.open.SpeechHeader header = 1;
  if (has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *request_content_.header_, false, target);
  }

  // optional bytes voice = 2;
  if (has_voice()) {
    target =
      ::google::protobuf::internal::WireFormatLite::WriteBytesToArray(
        2, this->voice(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:rokid.open.VoiceSpeechRequest)
  return target;
}

size_t VoiceSpeechRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rokid.open.VoiceSpeechRequest)
  size_t total_size = 0;

  switch (request_content_case()) {
    // optional .rokid.open.SpeechHeader header = 1;
    case kHeader: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
          *request_content_.header_);
      break;
    }
    // optional bytes voice = 2;
    case kVoice: {
      total_size += 1 +
        ::google::protobuf::internal::WireFormatLite::BytesSize(
          this->voice());
      break;
    }
    case REQUEST_CONTENT_NOT_SET: {
      break;
    }
  }
  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VoiceSpeechRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:rokid.open.VoiceSpeechRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const VoiceSpeechRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const VoiceSpeechRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:rokid.open.VoiceSpeechRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:rokid.open.VoiceSpeechRequest)
    UnsafeMergeFrom(*source);
  }
}

void VoiceSpeechRequest::MergeFrom(const VoiceSpeechRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rokid.open.VoiceSpeechRequest)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void VoiceSpeechRequest::UnsafeMergeFrom(const VoiceSpeechRequest& from) {
  GOOGLE_DCHECK(&from != this);
  switch (from.request_content_case()) {
    case kHeader: {
      mutable_header()->::rokid::open::SpeechHeader::MergeFrom(from.header());
      break;
    }
    case kVoice: {
      set_voice(from.voice());
      break;
    }
    case REQUEST_CONTENT_NOT_SET: {
      break;
    }
  }
}

void VoiceSpeechRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:rokid.open.VoiceSpeechRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VoiceSpeechRequest::CopyFrom(const VoiceSpeechRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rokid.open.VoiceSpeechRequest)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool VoiceSpeechRequest::IsInitialized() const {

  return true;
}

void VoiceSpeechRequest::Swap(VoiceSpeechRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VoiceSpeechRequest::InternalSwap(VoiceSpeechRequest* other) {
  std::swap(request_content_, other->request_content_);
  std::swap(_oneof_case_[0], other->_oneof_case_[0]);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata VoiceSpeechRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VoiceSpeechRequest_descriptor_;
  metadata.reflection = VoiceSpeechRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// VoiceSpeechRequest

// optional .rokid.open.SpeechHeader header = 1;
bool VoiceSpeechRequest::has_header() const {
  return request_content_case() == kHeader;
}
void VoiceSpeechRequest::set_has_header() {
  _oneof_case_[0] = kHeader;
}
void VoiceSpeechRequest::clear_header() {
  if (has_header()) {
    delete request_content_.header_;
    clear_has_request_content();
  }
}
 const ::rokid::open::SpeechHeader& VoiceSpeechRequest::header() const {
  // @@protoc_insertion_point(field_get:rokid.open.VoiceSpeechRequest.header)
  return has_header()
      ? *request_content_.header_
      : ::rokid::open::SpeechHeader::default_instance();
}
::rokid::open::SpeechHeader* VoiceSpeechRequest::mutable_header() {
  if (!has_header()) {
    clear_request_content();
    set_has_header();
    request_content_.header_ = new ::rokid::open::SpeechHeader;
  }
  // @@protoc_insertion_point(field_mutable:rokid.open.VoiceSpeechRequest.header)
  return request_content_.header_;
}
::rokid::open::SpeechHeader* VoiceSpeechRequest::release_header() {
  // @@protoc_insertion_point(field_release:rokid.open.VoiceSpeechRequest.header)
  if (has_header()) {
    clear_has_request_content();
    ::rokid::open::SpeechHeader* temp = request_content_.header_;
    request_content_.header_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
void VoiceSpeechRequest::set_allocated_header(::rokid::open::SpeechHeader* header) {
  clear_request_content();
  if (header) {
    set_has_header();
    request_content_.header_ = header;
  }
  // @@protoc_insertion_point(field_set_allocated:rokid.open.VoiceSpeechRequest.header)
}

// optional bytes voice = 2;
bool VoiceSpeechRequest::has_voice() const {
  return request_content_case() == kVoice;
}
void VoiceSpeechRequest::set_has_voice() {
  _oneof_case_[0] = kVoice;
}
void VoiceSpeechRequest::clear_voice() {
  if (has_voice()) {
    request_content_.voice_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_request_content();
  }
}
const ::std::string& VoiceSpeechRequest::voice() const {
  // @@protoc_insertion_point(field_get:rokid.open.VoiceSpeechRequest.voice)
  if (has_voice()) {
    return request_content_.voice_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
void VoiceSpeechRequest::set_voice(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:rokid.open.VoiceSpeechRequest.voice)
  if (!has_voice()) {
    clear_request_content();
    set_has_voice();
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  request_content_.voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.VoiceSpeechRequest.voice)
}
void VoiceSpeechRequest::set_voice(const char* value) {
  if (!has_voice()) {
    clear_request_content();
    set_has_voice();
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  request_content_.voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.VoiceSpeechRequest.voice)
}
void VoiceSpeechRequest::set_voice(const void* value, size_t size) {
  if (!has_voice()) {
    clear_request_content();
    set_has_voice();
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  request_content_.voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.VoiceSpeechRequest.voice)
}
::std::string* VoiceSpeechRequest::mutable_voice() {
  if (!has_voice()) {
    clear_request_content();
    set_has_voice();
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:rokid.open.VoiceSpeechRequest.voice)
  return request_content_.voice_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* VoiceSpeechRequest::release_voice() {
  // @@protoc_insertion_point(field_release:rokid.open.VoiceSpeechRequest.voice)
  if (has_voice()) {
    clear_has_request_content();
    return request_content_.voice_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
void VoiceSpeechRequest::set_allocated_voice(::std::string* voice) {
  if (!has_voice()) {
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_request_content();
  if (voice != NULL) {
    set_has_voice();
    request_content_.voice_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        voice);
  }
  // @@protoc_insertion_point(field_set_allocated:rokid.open.VoiceSpeechRequest.voice)
}

bool VoiceSpeechRequest::has_request_content() const {
  return request_content_case() != REQUEST_CONTENT_NOT_SET;
}
void VoiceSpeechRequest::clear_has_request_content() {
  _oneof_case_[0] = REQUEST_CONTENT_NOT_SET;
}
VoiceSpeechRequest::RequestContentCase VoiceSpeechRequest::request_content_case() const {
  return VoiceSpeechRequest::RequestContentCase(_oneof_case_[0]);
}
inline const VoiceSpeechRequest* VoiceSpeechRequest::internal_default_instance() {
  return &VoiceSpeechRequest_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int VoiceSpeechResponse::kAsrFieldNumber;
const int VoiceSpeechResponse::kNlpFieldNumber;
const int VoiceSpeechResponse::kActionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

VoiceSpeechResponse::VoiceSpeechResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_speech_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:rokid.open.VoiceSpeechResponse)
}

void VoiceSpeechResponse::InitAsDefaultInstance() {
}

VoiceSpeechResponse::VoiceSpeechResponse(const VoiceSpeechResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:rokid.open.VoiceSpeechResponse)
}

void VoiceSpeechResponse::SharedCtor() {
  asr_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nlp_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  action_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _cached_size_ = 0;
}

VoiceSpeechResponse::~VoiceSpeechResponse() {
  // @@protoc_insertion_point(destructor:rokid.open.VoiceSpeechResponse)
  SharedDtor();
}

void VoiceSpeechResponse::SharedDtor() {
  asr_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nlp_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  action_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void VoiceSpeechResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* VoiceSpeechResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return VoiceSpeechResponse_descriptor_;
}

const VoiceSpeechResponse& VoiceSpeechResponse::default_instance() {
  protobuf_InitDefaults_speech_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<VoiceSpeechResponse> VoiceSpeechResponse_default_instance_;

VoiceSpeechResponse* VoiceSpeechResponse::New(::google::protobuf::Arena* arena) const {
  VoiceSpeechResponse* n = new VoiceSpeechResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void VoiceSpeechResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:rokid.open.VoiceSpeechResponse)
  asr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nlp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  action_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool VoiceSpeechResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:rokid.open.VoiceSpeechResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string asr = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_asr()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->asr().data(), this->asr().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.VoiceSpeechResponse.asr"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_nlp;
        break;
      }

      // optional string nlp = 2;
      case 2: {
        if (tag == 18) {
         parse_nlp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nlp()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->nlp().data(), this->nlp().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.VoiceSpeechResponse.nlp"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_action;
        break;
      }

      // optional string action = 3;
      case 3: {
        if (tag == 26) {
         parse_action:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_action()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->action().data(), this->action().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.VoiceSpeechResponse.action"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:rokid.open.VoiceSpeechResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:rokid.open.VoiceSpeechResponse)
  return false;
#undef DO_
}

void VoiceSpeechResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:rokid.open.VoiceSpeechResponse)
  // optional string asr = 1;
  if (this->asr().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->asr().data(), this->asr().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.VoiceSpeechResponse.asr");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->asr(), output);
  }

  // optional string nlp = 2;
  if (this->nlp().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->nlp().data(), this->nlp().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.VoiceSpeechResponse.nlp");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->nlp(), output);
  }

  // optional string action = 3;
  if (this->action().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->action().data(), this->action().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.VoiceSpeechResponse.action");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->action(), output);
  }

  // @@protoc_insertion_point(serialize_end:rokid.open.VoiceSpeechResponse)
}

::google::protobuf::uint8* VoiceSpeechResponse::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:rokid.open.VoiceSpeechResponse)
  // optional string asr = 1;
  if (this->asr().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->asr().data(), this->asr().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.VoiceSpeechResponse.asr");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->asr(), target);
  }

  // optional string nlp = 2;
  if (this->nlp().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->nlp().data(), this->nlp().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.VoiceSpeechResponse.nlp");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->nlp(), target);
  }

  // optional string action = 3;
  if (this->action().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->action().data(), this->action().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.VoiceSpeechResponse.action");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->action(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:rokid.open.VoiceSpeechResponse)
  return target;
}

size_t VoiceSpeechResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rokid.open.VoiceSpeechResponse)
  size_t total_size = 0;

  // optional string asr = 1;
  if (this->asr().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->asr());
  }

  // optional string nlp = 2;
  if (this->nlp().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->nlp());
  }

  // optional string action = 3;
  if (this->action().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->action());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void VoiceSpeechResponse::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:rokid.open.VoiceSpeechResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const VoiceSpeechResponse* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const VoiceSpeechResponse>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:rokid.open.VoiceSpeechResponse)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:rokid.open.VoiceSpeechResponse)
    UnsafeMergeFrom(*source);
  }
}

void VoiceSpeechResponse::MergeFrom(const VoiceSpeechResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rokid.open.VoiceSpeechResponse)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void VoiceSpeechResponse::UnsafeMergeFrom(const VoiceSpeechResponse& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.asr().size() > 0) {

    asr_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.asr_);
  }
  if (from.nlp().size() > 0) {

    nlp_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nlp_);
  }
  if (from.action().size() > 0) {

    action_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.action_);
  }
}

void VoiceSpeechResponse::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:rokid.open.VoiceSpeechResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void VoiceSpeechResponse::CopyFrom(const VoiceSpeechResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rokid.open.VoiceSpeechResponse)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool VoiceSpeechResponse::IsInitialized() const {

  return true;
}

void VoiceSpeechResponse::Swap(VoiceSpeechResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void VoiceSpeechResponse::InternalSwap(VoiceSpeechResponse* other) {
  asr_.Swap(&other->asr_);
  nlp_.Swap(&other->nlp_);
  action_.Swap(&other->action_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata VoiceSpeechResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = VoiceSpeechResponse_descriptor_;
  metadata.reflection = VoiceSpeechResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// VoiceSpeechResponse

// optional string asr = 1;
void VoiceSpeechResponse::clear_asr() {
  asr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& VoiceSpeechResponse::asr() const {
  // @@protoc_insertion_point(field_get:rokid.open.VoiceSpeechResponse.asr)
  return asr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void VoiceSpeechResponse::set_asr(const ::std::string& value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.VoiceSpeechResponse.asr)
}
void VoiceSpeechResponse::set_asr(const char* value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.VoiceSpeechResponse.asr)
}
void VoiceSpeechResponse::set_asr(const char* value, size_t size) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.VoiceSpeechResponse.asr)
}
::std::string* VoiceSpeechResponse::mutable_asr() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.VoiceSpeechResponse.asr)
  return asr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* VoiceSpeechResponse::release_asr() {
  // @@protoc_insertion_point(field_release:rokid.open.VoiceSpeechResponse.asr)
  
  return asr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void VoiceSpeechResponse::set_allocated_asr(::std::string* asr) {
  if (asr != NULL) {
    
  } else {
    
  }
  asr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asr);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.VoiceSpeechResponse.asr)
}

// optional string nlp = 2;
void VoiceSpeechResponse::clear_nlp() {
  nlp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& VoiceSpeechResponse::nlp() const {
  // @@protoc_insertion_point(field_get:rokid.open.VoiceSpeechResponse.nlp)
  return nlp_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void VoiceSpeechResponse::set_nlp(const ::std::string& value) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.VoiceSpeechResponse.nlp)
}
void VoiceSpeechResponse::set_nlp(const char* value) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.VoiceSpeechResponse.nlp)
}
void VoiceSpeechResponse::set_nlp(const char* value, size_t size) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.VoiceSpeechResponse.nlp)
}
::std::string* VoiceSpeechResponse::mutable_nlp() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.VoiceSpeechResponse.nlp)
  return nlp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* VoiceSpeechResponse::release_nlp() {
  // @@protoc_insertion_point(field_release:rokid.open.VoiceSpeechResponse.nlp)
  
  return nlp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void VoiceSpeechResponse::set_allocated_nlp(::std::string* nlp) {
  if (nlp != NULL) {
    
  } else {
    
  }
  nlp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nlp);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.VoiceSpeechResponse.nlp)
}

// optional string action = 3;
void VoiceSpeechResponse::clear_action() {
  action_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& VoiceSpeechResponse::action() const {
  // @@protoc_insertion_point(field_get:rokid.open.VoiceSpeechResponse.action)
  return action_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void VoiceSpeechResponse::set_action(const ::std::string& value) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.VoiceSpeechResponse.action)
}
void VoiceSpeechResponse::set_action(const char* value) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.VoiceSpeechResponse.action)
}
void VoiceSpeechResponse::set_action(const char* value, size_t size) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.VoiceSpeechResponse.action)
}
::std::string* VoiceSpeechResponse::mutable_action() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.VoiceSpeechResponse.action)
  return action_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* VoiceSpeechResponse::release_action() {
  // @@protoc_insertion_point(field_release:rokid.open.VoiceSpeechResponse.action)
  
  return action_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void VoiceSpeechResponse::set_allocated_action(::std::string* action) {
  if (action != NULL) {
    
  } else {
    
  }
  action_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), action);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.VoiceSpeechResponse.action)
}

inline const VoiceSpeechResponse* VoiceSpeechResponse::internal_default_instance() {
  return &VoiceSpeechResponse_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TextSpeechRequest::kHeaderFieldNumber;
const int TextSpeechRequest::kAsrFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TextSpeechRequest::TextSpeechRequest()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_speech_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:rokid.open.TextSpeechRequest)
}

void TextSpeechRequest::InitAsDefaultInstance() {
  header_ = const_cast< ::rokid::open::SpeechHeader*>(
      ::rokid::open::SpeechHeader::internal_default_instance());
}

TextSpeechRequest::TextSpeechRequest(const TextSpeechRequest& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:rokid.open.TextSpeechRequest)
}

void TextSpeechRequest::SharedCtor() {
  asr_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  header_ = NULL;
  _cached_size_ = 0;
}

TextSpeechRequest::~TextSpeechRequest() {
  // @@protoc_insertion_point(destructor:rokid.open.TextSpeechRequest)
  SharedDtor();
}

void TextSpeechRequest::SharedDtor() {
  asr_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  if (this != &TextSpeechRequest_default_instance_.get()) {
    delete header_;
  }
}

void TextSpeechRequest::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TextSpeechRequest::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TextSpeechRequest_descriptor_;
}

const TextSpeechRequest& TextSpeechRequest::default_instance() {
  protobuf_InitDefaults_speech_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<TextSpeechRequest> TextSpeechRequest_default_instance_;

TextSpeechRequest* TextSpeechRequest::New(::google::protobuf::Arena* arena) const {
  TextSpeechRequest* n = new TextSpeechRequest;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TextSpeechRequest::Clear() {
// @@protoc_insertion_point(message_clear_start:rokid.open.TextSpeechRequest)
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
  asr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TextSpeechRequest::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:rokid.open.TextSpeechRequest)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional .rokid.open.SpeechHeader header = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadMessageNoVirtual(
               input, mutable_header()));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_asr;
        break;
      }

      // optional string asr = 2;
      case 2: {
        if (tag == 18) {
         parse_asr:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_asr()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->asr().data(), this->asr().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.TextSpeechRequest.asr"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:rokid.open.TextSpeechRequest)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:rokid.open.TextSpeechRequest)
  return false;
#undef DO_
}

void TextSpeechRequest::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:rokid.open.TextSpeechRequest)
  // optional .rokid.open.SpeechHeader header = 1;
  if (this->has_header()) {
    ::google::protobuf::internal::WireFormatLite::WriteMessageMaybeToArray(
      1, *this->header_, output);
  }

  // optional string asr = 2;
  if (this->asr().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->asr().data(), this->asr().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.TextSpeechRequest.asr");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->asr(), output);
  }

  // @@protoc_insertion_point(serialize_end:rokid.open.TextSpeechRequest)
}

::google::protobuf::uint8* TextSpeechRequest::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:rokid.open.TextSpeechRequest)
  // optional .rokid.open.SpeechHeader header = 1;
  if (this->has_header()) {
    target = ::google::protobuf::internal::WireFormatLite::
      InternalWriteMessageNoVirtualToArray(
        1, *this->header_, false, target);
  }

  // optional string asr = 2;
  if (this->asr().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->asr().data(), this->asr().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.TextSpeechRequest.asr");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->asr(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:rokid.open.TextSpeechRequest)
  return target;
}

size_t TextSpeechRequest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rokid.open.TextSpeechRequest)
  size_t total_size = 0;

  // optional .rokid.open.SpeechHeader header = 1;
  if (this->has_header()) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::MessageSizeNoVirtual(
        *this->header_);
  }

  // optional string asr = 2;
  if (this->asr().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->asr());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TextSpeechRequest::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:rokid.open.TextSpeechRequest)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TextSpeechRequest* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TextSpeechRequest>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:rokid.open.TextSpeechRequest)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:rokid.open.TextSpeechRequest)
    UnsafeMergeFrom(*source);
  }
}

void TextSpeechRequest::MergeFrom(const TextSpeechRequest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rokid.open.TextSpeechRequest)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void TextSpeechRequest::UnsafeMergeFrom(const TextSpeechRequest& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.has_header()) {
    mutable_header()->::rokid::open::SpeechHeader::MergeFrom(from.header());
  }
  if (from.asr().size() > 0) {

    asr_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.asr_);
  }
}

void TextSpeechRequest::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:rokid.open.TextSpeechRequest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TextSpeechRequest::CopyFrom(const TextSpeechRequest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rokid.open.TextSpeechRequest)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool TextSpeechRequest::IsInitialized() const {

  return true;
}

void TextSpeechRequest::Swap(TextSpeechRequest* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TextSpeechRequest::InternalSwap(TextSpeechRequest* other) {
  std::swap(header_, other->header_);
  asr_.Swap(&other->asr_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TextSpeechRequest::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TextSpeechRequest_descriptor_;
  metadata.reflection = TextSpeechRequest_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TextSpeechRequest

// optional .rokid.open.SpeechHeader header = 1;
bool TextSpeechRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
void TextSpeechRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
const ::rokid::open::SpeechHeader& TextSpeechRequest::header() const {
  // @@protoc_insertion_point(field_get:rokid.open.TextSpeechRequest.header)
  return header_ != NULL ? *header_
                         : *::rokid::open::SpeechHeader::internal_default_instance();
}
::rokid::open::SpeechHeader* TextSpeechRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::rokid::open::SpeechHeader;
  }
  // @@protoc_insertion_point(field_mutable:rokid.open.TextSpeechRequest.header)
  return header_;
}
::rokid::open::SpeechHeader* TextSpeechRequest::release_header() {
  // @@protoc_insertion_point(field_release:rokid.open.TextSpeechRequest.header)
  
  ::rokid::open::SpeechHeader* temp = header_;
  header_ = NULL;
  return temp;
}
void TextSpeechRequest::set_allocated_header(::rokid::open::SpeechHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TextSpeechRequest.header)
}

// optional string asr = 2;
void TextSpeechRequest::clear_asr() {
  asr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& TextSpeechRequest::asr() const {
  // @@protoc_insertion_point(field_get:rokid.open.TextSpeechRequest.asr)
  return asr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TextSpeechRequest::set_asr(const ::std::string& value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TextSpeechRequest.asr)
}
void TextSpeechRequest::set_asr(const char* value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TextSpeechRequest.asr)
}
void TextSpeechRequest::set_asr(const char* value, size_t size) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TextSpeechRequest.asr)
}
::std::string* TextSpeechRequest::mutable_asr() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TextSpeechRequest.asr)
  return asr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TextSpeechRequest::release_asr() {
  // @@protoc_insertion_point(field_release:rokid.open.TextSpeechRequest.asr)
  
  return asr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TextSpeechRequest::set_allocated_asr(::std::string* asr) {
  if (asr != NULL) {
    
  } else {
    
  }
  asr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asr);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TextSpeechRequest.asr)
}

inline const TextSpeechRequest* TextSpeechRequest::internal_default_instance() {
  return &TextSpeechRequest_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int TextSpeechResponse::kAsrFieldNumber;
const int TextSpeechResponse::kNlpFieldNumber;
const int TextSpeechResponse::kActionFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

TextSpeechResponse::TextSpeechResponse()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_speech_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:rokid.open.TextSpeechResponse)
}

void TextSpeechResponse::InitAsDefaultInstance() {
}

TextSpeechResponse::TextSpeechResponse(const TextSpeechResponse& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:rokid.open.TextSpeechResponse)
}

void TextSpeechResponse::SharedCtor() {
  asr_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nlp_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  action_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _cached_size_ = 0;
}

TextSpeechResponse::~TextSpeechResponse() {
  // @@protoc_insertion_point(destructor:rokid.open.TextSpeechResponse)
  SharedDtor();
}

void TextSpeechResponse::SharedDtor() {
  asr_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nlp_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  action_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void TextSpeechResponse::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* TextSpeechResponse::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return TextSpeechResponse_descriptor_;
}

const TextSpeechResponse& TextSpeechResponse::default_instance() {
  protobuf_InitDefaults_speech_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<TextSpeechResponse> TextSpeechResponse_default_instance_;

TextSpeechResponse* TextSpeechResponse::New(::google::protobuf::Arena* arena) const {
  TextSpeechResponse* n = new TextSpeechResponse;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void TextSpeechResponse::Clear() {
// @@protoc_insertion_point(message_clear_start:rokid.open.TextSpeechResponse)
  asr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  nlp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  action_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool TextSpeechResponse::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:rokid.open.TextSpeechResponse)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional string asr = 1;
      case 1: {
        if (tag == 10) {
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_asr()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->asr().data(), this->asr().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.TextSpeechResponse.asr"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_nlp;
        break;
      }

      // optional string nlp = 2;
      case 2: {
        if (tag == 18) {
         parse_nlp:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_nlp()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->nlp().data(), this->nlp().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.TextSpeechResponse.nlp"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_action;
        break;
      }

      // optional string action = 3;
      case 3: {
        if (tag == 26) {
         parse_action:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_action()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->action().data(), this->action().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.TextSpeechResponse.action"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:rokid.open.TextSpeechResponse)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:rokid.open.TextSpeechResponse)
  return false;
#undef DO_
}

void TextSpeechResponse::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:rokid.open.TextSpeechResponse)
  // optional string asr = 1;
  if (this->asr().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->asr().data(), this->asr().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.TextSpeechResponse.asr");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      1, this->asr(), output);
  }

  // optional string nlp = 2;
  if (this->nlp().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->nlp().data(), this->nlp().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.TextSpeechResponse.nlp");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->nlp(), output);
  }

  // optional string action = 3;
  if (this->action().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->action().data(), this->action().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.TextSpeechResponse.action");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->action(), output);
  }

  // @@protoc_insertion_point(serialize_end:rokid.open.TextSpeechResponse)
}

::google::protobuf::uint8* TextSpeechResponse::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:rokid.open.TextSpeechResponse)
  // optional string asr = 1;
  if (this->asr().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->asr().data(), this->asr().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.TextSpeechResponse.asr");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        1, this->asr(), target);
  }

  // optional string nlp = 2;
  if (this->nlp().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->nlp().data(), this->nlp().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.TextSpeechResponse.nlp");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->nlp(), target);
  }

  // optional string action = 3;
  if (this->action().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->action().data(), this->action().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.TextSpeechResponse.action");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->action(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:rokid.open.TextSpeechResponse)
  return target;
}

size_t TextSpeechResponse::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rokid.open.TextSpeechResponse)
  size_t total_size = 0;

  // optional string asr = 1;
  if (this->asr().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->asr());
  }

  // optional string nlp = 2;
  if (this->nlp().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->nlp());
  }

  // optional string action = 3;
  if (this->action().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->action());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void TextSpeechResponse::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:rokid.open.TextSpeechResponse)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const TextSpeechResponse* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const TextSpeechResponse>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:rokid.open.TextSpeechResponse)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:rokid.open.TextSpeechResponse)
    UnsafeMergeFrom(*source);
  }
}

void TextSpeechResponse::MergeFrom(const TextSpeechResponse& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rokid.open.TextSpeechResponse)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void TextSpeechResponse::UnsafeMergeFrom(const TextSpeechResponse& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.asr().size() > 0) {

    asr_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.asr_);
  }
  if (from.nlp().size() > 0) {

    nlp_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.nlp_);
  }
  if (from.action().size() > 0) {

    action_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.action_);
  }
}

void TextSpeechResponse::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:rokid.open.TextSpeechResponse)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void TextSpeechResponse::CopyFrom(const TextSpeechResponse& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rokid.open.TextSpeechResponse)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool TextSpeechResponse::IsInitialized() const {

  return true;
}

void TextSpeechResponse::Swap(TextSpeechResponse* other) {
  if (other == this) return;
  InternalSwap(other);
}
void TextSpeechResponse::InternalSwap(TextSpeechResponse* other) {
  asr_.Swap(&other->asr_);
  nlp_.Swap(&other->nlp_);
  action_.Swap(&other->action_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata TextSpeechResponse::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = TextSpeechResponse_descriptor_;
  metadata.reflection = TextSpeechResponse_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// TextSpeechResponse

// optional string asr = 1;
void TextSpeechResponse::clear_asr() {
  asr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& TextSpeechResponse::asr() const {
  // @@protoc_insertion_point(field_get:rokid.open.TextSpeechResponse.asr)
  return asr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TextSpeechResponse::set_asr(const ::std::string& value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TextSpeechResponse.asr)
}
void TextSpeechResponse::set_asr(const char* value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TextSpeechResponse.asr)
}
void TextSpeechResponse::set_asr(const char* value, size_t size) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TextSpeechResponse.asr)
}
::std::string* TextSpeechResponse::mutable_asr() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TextSpeechResponse.asr)
  return asr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TextSpeechResponse::release_asr() {
  // @@protoc_insertion_point(field_release:rokid.open.TextSpeechResponse.asr)
  
  return asr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TextSpeechResponse::set_allocated_asr(::std::string* asr) {
  if (asr != NULL) {
    
  } else {
    
  }
  asr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asr);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TextSpeechResponse.asr)
}

// optional string nlp = 2;
void TextSpeechResponse::clear_nlp() {
  nlp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& TextSpeechResponse::nlp() const {
  // @@protoc_insertion_point(field_get:rokid.open.TextSpeechResponse.nlp)
  return nlp_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TextSpeechResponse::set_nlp(const ::std::string& value) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TextSpeechResponse.nlp)
}
void TextSpeechResponse::set_nlp(const char* value) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TextSpeechResponse.nlp)
}
void TextSpeechResponse::set_nlp(const char* value, size_t size) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TextSpeechResponse.nlp)
}
::std::string* TextSpeechResponse::mutable_nlp() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TextSpeechResponse.nlp)
  return nlp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TextSpeechResponse::release_nlp() {
  // @@protoc_insertion_point(field_release:rokid.open.TextSpeechResponse.nlp)
  
  return nlp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TextSpeechResponse::set_allocated_nlp(::std::string* nlp) {
  if (nlp != NULL) {
    
  } else {
    
  }
  nlp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nlp);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TextSpeechResponse.nlp)
}

// optional string action = 3;
void TextSpeechResponse::clear_action() {
  action_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& TextSpeechResponse::action() const {
  // @@protoc_insertion_point(field_get:rokid.open.TextSpeechResponse.action)
  return action_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TextSpeechResponse::set_action(const ::std::string& value) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TextSpeechResponse.action)
}
void TextSpeechResponse::set_action(const char* value) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TextSpeechResponse.action)
}
void TextSpeechResponse::set_action(const char* value, size_t size) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TextSpeechResponse.action)
}
::std::string* TextSpeechResponse::mutable_action() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TextSpeechResponse.action)
  return action_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* TextSpeechResponse::release_action() {
  // @@protoc_insertion_point(field_release:rokid.open.TextSpeechResponse.action)
  
  return action_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void TextSpeechResponse::set_allocated_action(::std::string* action) {
  if (action != NULL) {
    
  } else {
    
  }
  action_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), action);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TextSpeechResponse.action)
}

inline const TextSpeechResponse* TextSpeechResponse::internal_default_instance() {
  return &TextSpeechResponse_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// ===================================================================

#if !defined(_MSC_VER) || _MSC_VER >= 1900
const int SpeechHeader::kIdFieldNumber;
const int SpeechHeader::kLanguageFieldNumber;
const int SpeechHeader::kCodecFieldNumber;
const int SpeechHeader::kVtFieldNumber;
const int SpeechHeader::kCdomainFieldNumber;
const int SpeechHeader::kDeviceFieldNumber;
#endif  // !defined(_MSC_VER) || _MSC_VER >= 1900

SpeechHeader::SpeechHeader()
  : ::google::protobuf::Message(), _internal_metadata_(NULL) {
  if (this != internal_default_instance()) protobuf_InitDefaults_speech_2eproto();
  SharedCtor();
  // @@protoc_insertion_point(constructor:rokid.open.SpeechHeader)
}

void SpeechHeader::InitAsDefaultInstance() {
}

SpeechHeader::SpeechHeader(const SpeechHeader& from)
  : ::google::protobuf::Message(),
    _internal_metadata_(NULL) {
  SharedCtor();
  UnsafeMergeFrom(from);
  // @@protoc_insertion_point(copy_constructor:rokid.open.SpeechHeader)
}

void SpeechHeader::SharedCtor() {
  language_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  codec_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vt_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cdomain_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  id_ = 0;
  _cached_size_ = 0;
}

SpeechHeader::~SpeechHeader() {
  // @@protoc_insertion_point(destructor:rokid.open.SpeechHeader)
  SharedDtor();
}

void SpeechHeader::SharedDtor() {
  language_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  codec_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vt_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cdomain_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

void SpeechHeader::SetCachedSize(int size) const {
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
}
const ::google::protobuf::Descriptor* SpeechHeader::descriptor() {
  protobuf_AssignDescriptorsOnce();
  return SpeechHeader_descriptor_;
}

const SpeechHeader& SpeechHeader::default_instance() {
  protobuf_InitDefaults_speech_2eproto();
  return *internal_default_instance();
}

::google::protobuf::internal::ExplicitlyConstructed<SpeechHeader> SpeechHeader_default_instance_;

SpeechHeader* SpeechHeader::New(::google::protobuf::Arena* arena) const {
  SpeechHeader* n = new SpeechHeader;
  if (arena != NULL) {
    arena->Own(n);
  }
  return n;
}

void SpeechHeader::Clear() {
// @@protoc_insertion_point(message_clear_start:rokid.open.SpeechHeader)
  id_ = 0;
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  codec_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  vt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  cdomain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  device_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}

bool SpeechHeader::MergePartialFromCodedStream(
    ::google::protobuf::io::CodedInputStream* input) {
#define DO_(EXPRESSION) if (!GOOGLE_PREDICT_TRUE(EXPRESSION)) goto failure
  ::google::protobuf::uint32 tag;
  // @@protoc_insertion_point(parse_start:rokid.open.SpeechHeader)
  for (;;) {
    ::std::pair< ::google::protobuf::uint32, bool> p = input->ReadTagWithCutoff(127);
    tag = p.first;
    if (!p.second) goto handle_unusual;
    switch (::google::protobuf::internal::WireFormatLite::GetTagFieldNumber(tag)) {
      // optional int32 id = 1;
      case 1: {
        if (tag == 8) {

          DO_((::google::protobuf::internal::WireFormatLite::ReadPrimitive<
                   ::google::protobuf::int32, ::google::protobuf::internal::WireFormatLite::TYPE_INT32>(
                 input, &id_)));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(18)) goto parse_language;
        break;
      }

      // optional string language = 2;
      case 2: {
        if (tag == 18) {
         parse_language:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_language()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->language().data(), this->language().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.SpeechHeader.language"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(26)) goto parse_codec;
        break;
      }

      // optional string codec = 3;
      case 3: {
        if (tag == 26) {
         parse_codec:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_codec()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->codec().data(), this->codec().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.SpeechHeader.codec"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(34)) goto parse_vt;
        break;
      }

      // optional string vt = 4;
      case 4: {
        if (tag == 34) {
         parse_vt:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_vt()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->vt().data(), this->vt().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.SpeechHeader.vt"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(42)) goto parse_cdomain;
        break;
      }

      // optional string cdomain = 5;
      case 5: {
        if (tag == 42) {
         parse_cdomain:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_cdomain()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->cdomain().data(), this->cdomain().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.SpeechHeader.cdomain"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectTag(50)) goto parse_device;
        break;
      }

      // optional string device = 6;
      case 6: {
        if (tag == 50) {
         parse_device:
          DO_(::google::protobuf::internal::WireFormatLite::ReadString(
                input, this->mutable_device()));
          DO_(::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
            this->device().data(), this->device().length(),
            ::google::protobuf::internal::WireFormatLite::PARSE,
            "rokid.open.SpeechHeader.device"));
        } else {
          goto handle_unusual;
        }
        if (input->ExpectAtEnd()) goto success;
        break;
      }

      default: {
      handle_unusual:
        if (tag == 0 ||
            ::google::protobuf::internal::WireFormatLite::GetTagWireType(tag) ==
            ::google::protobuf::internal::WireFormatLite::WIRETYPE_END_GROUP) {
          goto success;
        }
        DO_(::google::protobuf::internal::WireFormatLite::SkipField(input, tag));
        break;
      }
    }
  }
success:
  // @@protoc_insertion_point(parse_success:rokid.open.SpeechHeader)
  return true;
failure:
  // @@protoc_insertion_point(parse_failure:rokid.open.SpeechHeader)
  return false;
#undef DO_
}

void SpeechHeader::SerializeWithCachedSizes(
    ::google::protobuf::io::CodedOutputStream* output) const {
  // @@protoc_insertion_point(serialize_start:rokid.open.SpeechHeader)
  // optional int32 id = 1;
  if (this->id() != 0) {
    ::google::protobuf::internal::WireFormatLite::WriteInt32(1, this->id(), output);
  }

  // optional string language = 2;
  if (this->language().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.SpeechHeader.language");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      2, this->language(), output);
  }

  // optional string codec = 3;
  if (this->codec().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->codec().data(), this->codec().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.SpeechHeader.codec");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      3, this->codec(), output);
  }

  // optional string vt = 4;
  if (this->vt().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vt().data(), this->vt().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.SpeechHeader.vt");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      4, this->vt(), output);
  }

  // optional string cdomain = 5;
  if (this->cdomain().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->cdomain().data(), this->cdomain().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.SpeechHeader.cdomain");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      5, this->cdomain(), output);
  }

  // optional string device = 6;
  if (this->device().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->device().data(), this->device().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.SpeechHeader.device");
    ::google::protobuf::internal::WireFormatLite::WriteStringMaybeAliased(
      6, this->device(), output);
  }

  // @@protoc_insertion_point(serialize_end:rokid.open.SpeechHeader)
}

::google::protobuf::uint8* SpeechHeader::InternalSerializeWithCachedSizesToArray(
    bool deterministic, ::google::protobuf::uint8* target) const {
  (void)deterministic; // Unused
  // @@protoc_insertion_point(serialize_to_array_start:rokid.open.SpeechHeader)
  // optional int32 id = 1;
  if (this->id() != 0) {
    target = ::google::protobuf::internal::WireFormatLite::WriteInt32ToArray(1, this->id(), target);
  }

  // optional string language = 2;
  if (this->language().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->language().data(), this->language().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.SpeechHeader.language");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        2, this->language(), target);
  }

  // optional string codec = 3;
  if (this->codec().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->codec().data(), this->codec().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.SpeechHeader.codec");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        3, this->codec(), target);
  }

  // optional string vt = 4;
  if (this->vt().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->vt().data(), this->vt().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.SpeechHeader.vt");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        4, this->vt(), target);
  }

  // optional string cdomain = 5;
  if (this->cdomain().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->cdomain().data(), this->cdomain().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.SpeechHeader.cdomain");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        5, this->cdomain(), target);
  }

  // optional string device = 6;
  if (this->device().size() > 0) {
    ::google::protobuf::internal::WireFormatLite::VerifyUtf8String(
      this->device().data(), this->device().length(),
      ::google::protobuf::internal::WireFormatLite::SERIALIZE,
      "rokid.open.SpeechHeader.device");
    target =
      ::google::protobuf::internal::WireFormatLite::WriteStringToArray(
        6, this->device(), target);
  }

  // @@protoc_insertion_point(serialize_to_array_end:rokid.open.SpeechHeader)
  return target;
}

size_t SpeechHeader::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:rokid.open.SpeechHeader)
  size_t total_size = 0;

  // optional int32 id = 1;
  if (this->id() != 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::Int32Size(
        this->id());
  }

  // optional string language = 2;
  if (this->language().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->language());
  }

  // optional string codec = 3;
  if (this->codec().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->codec());
  }

  // optional string vt = 4;
  if (this->vt().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->vt());
  }

  // optional string cdomain = 5;
  if (this->cdomain().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->cdomain());
  }

  // optional string device = 6;
  if (this->device().size() > 0) {
    total_size += 1 +
      ::google::protobuf::internal::WireFormatLite::StringSize(
        this->device());
  }

  int cached_size = ::google::protobuf::internal::ToCachedSize(total_size);
  GOOGLE_SAFE_CONCURRENT_WRITES_BEGIN();
  _cached_size_ = cached_size;
  GOOGLE_SAFE_CONCURRENT_WRITES_END();
  return total_size;
}

void SpeechHeader::MergeFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_merge_from_start:rokid.open.SpeechHeader)
  if (GOOGLE_PREDICT_FALSE(&from == this)) MergeFromFail(__LINE__);
  const SpeechHeader* source =
      ::google::protobuf::internal::DynamicCastToGenerated<const SpeechHeader>(
          &from);
  if (source == NULL) {
  // @@protoc_insertion_point(generalized_merge_from_cast_fail:rokid.open.SpeechHeader)
    ::google::protobuf::internal::ReflectionOps::Merge(from, this);
  } else {
  // @@protoc_insertion_point(generalized_merge_from_cast_success:rokid.open.SpeechHeader)
    UnsafeMergeFrom(*source);
  }
}

void SpeechHeader::MergeFrom(const SpeechHeader& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:rokid.open.SpeechHeader)
  if (GOOGLE_PREDICT_TRUE(&from != this)) {
    UnsafeMergeFrom(from);
  } else {
    MergeFromFail(__LINE__);
  }
}

void SpeechHeader::UnsafeMergeFrom(const SpeechHeader& from) {
  GOOGLE_DCHECK(&from != this);
  if (from.id() != 0) {
    set_id(from.id());
  }
  if (from.language().size() > 0) {

    language_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.language_);
  }
  if (from.codec().size() > 0) {

    codec_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.codec_);
  }
  if (from.vt().size() > 0) {

    vt_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.vt_);
  }
  if (from.cdomain().size() > 0) {

    cdomain_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.cdomain_);
  }
  if (from.device().size() > 0) {

    device_.AssignWithDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), from.device_);
  }
}

void SpeechHeader::CopyFrom(const ::google::protobuf::Message& from) {
// @@protoc_insertion_point(generalized_copy_from_start:rokid.open.SpeechHeader)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

void SpeechHeader::CopyFrom(const SpeechHeader& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:rokid.open.SpeechHeader)
  if (&from == this) return;
  Clear();
  UnsafeMergeFrom(from);
}

bool SpeechHeader::IsInitialized() const {

  return true;
}

void SpeechHeader::Swap(SpeechHeader* other) {
  if (other == this) return;
  InternalSwap(other);
}
void SpeechHeader::InternalSwap(SpeechHeader* other) {
  std::swap(id_, other->id_);
  language_.Swap(&other->language_);
  codec_.Swap(&other->codec_);
  vt_.Swap(&other->vt_);
  cdomain_.Swap(&other->cdomain_);
  device_.Swap(&other->device_);
  _internal_metadata_.Swap(&other->_internal_metadata_);
  std::swap(_cached_size_, other->_cached_size_);
}

::google::protobuf::Metadata SpeechHeader::GetMetadata() const {
  protobuf_AssignDescriptorsOnce();
  ::google::protobuf::Metadata metadata;
  metadata.descriptor = SpeechHeader_descriptor_;
  metadata.reflection = SpeechHeader_reflection_;
  return metadata;
}

#if PROTOBUF_INLINE_NOT_IN_HEADERS
// SpeechHeader

// optional int32 id = 1;
void SpeechHeader::clear_id() {
  id_ = 0;
}
::google::protobuf::int32 SpeechHeader::id() const {
  // @@protoc_insertion_point(field_get:rokid.open.SpeechHeader.id)
  return id_;
}
void SpeechHeader::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:rokid.open.SpeechHeader.id)
}

// optional string language = 2;
void SpeechHeader::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& SpeechHeader::language() const {
  // @@protoc_insertion_point(field_get:rokid.open.SpeechHeader.language)
  return language_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SpeechHeader::set_language(const ::std::string& value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.SpeechHeader.language)
}
void SpeechHeader::set_language(const char* value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.SpeechHeader.language)
}
void SpeechHeader::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.SpeechHeader.language)
}
::std::string* SpeechHeader::mutable_language() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.SpeechHeader.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SpeechHeader::release_language() {
  // @@protoc_insertion_point(field_release:rokid.open.SpeechHeader.language)
  
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SpeechHeader::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.SpeechHeader.language)
}

// optional string codec = 3;
void SpeechHeader::clear_codec() {
  codec_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& SpeechHeader::codec() const {
  // @@protoc_insertion_point(field_get:rokid.open.SpeechHeader.codec)
  return codec_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SpeechHeader::set_codec(const ::std::string& value) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.SpeechHeader.codec)
}
void SpeechHeader::set_codec(const char* value) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.SpeechHeader.codec)
}
void SpeechHeader::set_codec(const char* value, size_t size) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.SpeechHeader.codec)
}
::std::string* SpeechHeader::mutable_codec() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.SpeechHeader.codec)
  return codec_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SpeechHeader::release_codec() {
  // @@protoc_insertion_point(field_release:rokid.open.SpeechHeader.codec)
  
  return codec_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SpeechHeader::set_allocated_codec(::std::string* codec) {
  if (codec != NULL) {
    
  } else {
    
  }
  codec_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codec);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.SpeechHeader.codec)
}

// optional string vt = 4;
void SpeechHeader::clear_vt() {
  vt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& SpeechHeader::vt() const {
  // @@protoc_insertion_point(field_get:rokid.open.SpeechHeader.vt)
  return vt_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SpeechHeader::set_vt(const ::std::string& value) {
  
  vt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.SpeechHeader.vt)
}
void SpeechHeader::set_vt(const char* value) {
  
  vt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.SpeechHeader.vt)
}
void SpeechHeader::set_vt(const char* value, size_t size) {
  
  vt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.SpeechHeader.vt)
}
::std::string* SpeechHeader::mutable_vt() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.SpeechHeader.vt)
  return vt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SpeechHeader::release_vt() {
  // @@protoc_insertion_point(field_release:rokid.open.SpeechHeader.vt)
  
  return vt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SpeechHeader::set_allocated_vt(::std::string* vt) {
  if (vt != NULL) {
    
  } else {
    
  }
  vt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vt);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.SpeechHeader.vt)
}

// optional string cdomain = 5;
void SpeechHeader::clear_cdomain() {
  cdomain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& SpeechHeader::cdomain() const {
  // @@protoc_insertion_point(field_get:rokid.open.SpeechHeader.cdomain)
  return cdomain_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SpeechHeader::set_cdomain(const ::std::string& value) {
  
  cdomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.SpeechHeader.cdomain)
}
void SpeechHeader::set_cdomain(const char* value) {
  
  cdomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.SpeechHeader.cdomain)
}
void SpeechHeader::set_cdomain(const char* value, size_t size) {
  
  cdomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.SpeechHeader.cdomain)
}
::std::string* SpeechHeader::mutable_cdomain() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.SpeechHeader.cdomain)
  return cdomain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SpeechHeader::release_cdomain() {
  // @@protoc_insertion_point(field_release:rokid.open.SpeechHeader.cdomain)
  
  return cdomain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SpeechHeader::set_allocated_cdomain(::std::string* cdomain) {
  if (cdomain != NULL) {
    
  } else {
    
  }
  cdomain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cdomain);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.SpeechHeader.cdomain)
}

// optional string device = 6;
void SpeechHeader::clear_device() {
  device_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
const ::std::string& SpeechHeader::device() const {
  // @@protoc_insertion_point(field_get:rokid.open.SpeechHeader.device)
  return device_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SpeechHeader::set_device(const ::std::string& value) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.SpeechHeader.device)
}
void SpeechHeader::set_device(const char* value) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.SpeechHeader.device)
}
void SpeechHeader::set_device(const char* value, size_t size) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.SpeechHeader.device)
}
::std::string* SpeechHeader::mutable_device() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.SpeechHeader.device)
  return device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
::std::string* SpeechHeader::release_device() {
  // @@protoc_insertion_point(field_release:rokid.open.SpeechHeader.device)
  
  return device_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
void SpeechHeader::set_allocated_device(::std::string* device) {
  if (device != NULL) {
    
  } else {
    
  }
  device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.SpeechHeader.device)
}

inline const SpeechHeader* SpeechHeader::internal_default_instance() {
  return &SpeechHeader_default_instance_.get();
}
#endif  // PROTOBUF_INLINE_NOT_IN_HEADERS

// @@protoc_insertion_point(namespace_scope)

}  // namespace open
}  // namespace rokid

// @@protoc_insertion_point(global_scope)
