// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: speech.proto

#ifndef PROTOBUF_speech_2eproto__INCLUDED
#define PROTOBUF_speech_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace rokid {
namespace open {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_speech_2eproto();
void protobuf_InitDefaults_speech_2eproto();
void protobuf_AssignDesc_speech_2eproto();
void protobuf_ShutdownFile_speech_2eproto();

class AsrHeader;
class AsrRequest;
class AsrResponse;
class NlpHeader;
class NlpRequest;
class NlpResponse;
class SpeechHeader;
class TextSpeechRequest;
class TextSpeechResponse;
class TtsHeader;
class TtsRequest;
class TtsResponse;
class VoiceSpeechRequest;
class VoiceSpeechResponse;

// ===================================================================

class AsrRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rokid.open.AsrRequest) */ {
 public:
  AsrRequest();
  virtual ~AsrRequest();

  AsrRequest(const AsrRequest& from);

  inline AsrRequest& operator=(const AsrRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AsrRequest& default_instance();

  enum RequestContentCase {
    kHeader = 1,
    kVoice = 2,
    REQUEST_CONTENT_NOT_SET = 0,
  };

  static const AsrRequest* internal_default_instance();

  void Swap(AsrRequest* other);

  // implements Message ----------------------------------------------

  inline AsrRequest* New() const { return New(NULL); }

  AsrRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AsrRequest& from);
  void MergeFrom(const AsrRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AsrRequest* other);
  void UnsafeMergeFrom(const AsrRequest& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .rokid.open.AsrHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::rokid::open::AsrHeader& header() const;
  ::rokid::open::AsrHeader* mutable_header();
  ::rokid::open::AsrHeader* release_header();
  void set_allocated_header(::rokid::open::AsrHeader* header);

  // optional bytes voice = 2;
  private:
  bool has_voice() const;
  public:
  void clear_voice();
  static const int kVoiceFieldNumber = 2;
  const ::std::string& voice() const;
  void set_voice(const ::std::string& value);
  void set_voice(const char* value);
  void set_voice(const void* value, size_t size);
  ::std::string* mutable_voice();
  ::std::string* release_voice();
  void set_allocated_voice(::std::string* voice);

  RequestContentCase request_content_case() const;
  // @@protoc_insertion_point(class_scope:rokid.open.AsrRequest)
 private:
  inline void set_has_header();
  inline void set_has_voice();

  inline bool has_request_content() const;
  void clear_request_content();
  inline void clear_has_request_content();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union RequestContentUnion {
    RequestContentUnion() {}
    ::rokid::open::AsrHeader* header_;
    ::google::protobuf::internal::ArenaStringPtr voice_;
  } request_content_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_speech_2eproto_impl();
  friend void  protobuf_AddDesc_speech_2eproto_impl();
  friend void protobuf_AssignDesc_speech_2eproto();
  friend void protobuf_ShutdownFile_speech_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AsrRequest> AsrRequest_default_instance_;

// -------------------------------------------------------------------

class AsrHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rokid.open.AsrHeader) */ {
 public:
  AsrHeader();
  virtual ~AsrHeader();

  AsrHeader(const AsrHeader& from);

  inline AsrHeader& operator=(const AsrHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AsrHeader& default_instance();

  static const AsrHeader* internal_default_instance();

  void Swap(AsrHeader* other);

  // implements Message ----------------------------------------------

  inline AsrHeader* New() const { return New(NULL); }

  AsrHeader* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AsrHeader& from);
  void MergeFrom(const AsrHeader& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AsrHeader* other);
  void UnsafeMergeFrom(const AsrHeader& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional string lang = 2;
  void clear_lang();
  static const int kLangFieldNumber = 2;
  const ::std::string& lang() const;
  void set_lang(const ::std::string& value);
  void set_lang(const char* value);
  void set_lang(const char* value, size_t size);
  ::std::string* mutable_lang();
  ::std::string* release_lang();
  void set_allocated_lang(::std::string* lang);

  // optional string codec = 3;
  void clear_codec();
  static const int kCodecFieldNumber = 3;
  const ::std::string& codec() const;
  void set_codec(const ::std::string& value);
  void set_codec(const char* value);
  void set_codec(const char* value, size_t size);
  ::std::string* mutable_codec();
  ::std::string* release_codec();
  void set_allocated_codec(::std::string* codec);

  // optional string vt = 4;
  void clear_vt();
  static const int kVtFieldNumber = 4;
  const ::std::string& vt() const;
  void set_vt(const ::std::string& value);
  void set_vt(const char* value);
  void set_vt(const char* value, size_t size);
  ::std::string* mutable_vt();
  ::std::string* release_vt();
  void set_allocated_vt(::std::string* vt);

  // @@protoc_insertion_point(class_scope:rokid.open.AsrHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr lang_;
  ::google::protobuf::internal::ArenaStringPtr codec_;
  ::google::protobuf::internal::ArenaStringPtr vt_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_speech_2eproto_impl();
  friend void  protobuf_AddDesc_speech_2eproto_impl();
  friend void protobuf_AssignDesc_speech_2eproto();
  friend void protobuf_ShutdownFile_speech_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AsrHeader> AsrHeader_default_instance_;

// -------------------------------------------------------------------

class AsrResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rokid.open.AsrResponse) */ {
 public:
  AsrResponse();
  virtual ~AsrResponse();

  AsrResponse(const AsrResponse& from);

  inline AsrResponse& operator=(const AsrResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AsrResponse& default_instance();

  static const AsrResponse* internal_default_instance();

  void Swap(AsrResponse* other);

  // implements Message ----------------------------------------------

  inline AsrResponse* New() const { return New(NULL); }

  AsrResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AsrResponse& from);
  void MergeFrom(const AsrResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(AsrResponse* other);
  void UnsafeMergeFrom(const AsrResponse& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string asr = 1;
  void clear_asr();
  static const int kAsrFieldNumber = 1;
  const ::std::string& asr() const;
  void set_asr(const ::std::string& value);
  void set_asr(const char* value);
  void set_asr(const char* value, size_t size);
  ::std::string* mutable_asr();
  ::std::string* release_asr();
  void set_allocated_asr(::std::string* asr);

  // @@protoc_insertion_point(class_scope:rokid.open.AsrResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr asr_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_speech_2eproto_impl();
  friend void  protobuf_AddDesc_speech_2eproto_impl();
  friend void protobuf_AssignDesc_speech_2eproto();
  friend void protobuf_ShutdownFile_speech_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<AsrResponse> AsrResponse_default_instance_;

// -------------------------------------------------------------------

class NlpRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rokid.open.NlpRequest) */ {
 public:
  NlpRequest();
  virtual ~NlpRequest();

  NlpRequest(const NlpRequest& from);

  inline NlpRequest& operator=(const NlpRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NlpRequest& default_instance();

  static const NlpRequest* internal_default_instance();

  void Swap(NlpRequest* other);

  // implements Message ----------------------------------------------

  inline NlpRequest* New() const { return New(NULL); }

  NlpRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NlpRequest& from);
  void MergeFrom(const NlpRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NlpRequest* other);
  void UnsafeMergeFrom(const NlpRequest& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .rokid.open.NlpHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::rokid::open::NlpHeader& header() const;
  ::rokid::open::NlpHeader* mutable_header();
  ::rokid::open::NlpHeader* release_header();
  void set_allocated_header(::rokid::open::NlpHeader* header);

  // optional string asr = 2;
  void clear_asr();
  static const int kAsrFieldNumber = 2;
  const ::std::string& asr() const;
  void set_asr(const ::std::string& value);
  void set_asr(const char* value);
  void set_asr(const char* value, size_t size);
  ::std::string* mutable_asr();
  ::std::string* release_asr();
  void set_allocated_asr(::std::string* asr);

  // @@protoc_insertion_point(class_scope:rokid.open.NlpRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr asr_;
  ::rokid::open::NlpHeader* header_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_speech_2eproto_impl();
  friend void  protobuf_AddDesc_speech_2eproto_impl();
  friend void protobuf_AssignDesc_speech_2eproto();
  friend void protobuf_ShutdownFile_speech_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<NlpRequest> NlpRequest_default_instance_;

// -------------------------------------------------------------------

class NlpHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rokid.open.NlpHeader) */ {
 public:
  NlpHeader();
  virtual ~NlpHeader();

  NlpHeader(const NlpHeader& from);

  inline NlpHeader& operator=(const NlpHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NlpHeader& default_instance();

  static const NlpHeader* internal_default_instance();

  void Swap(NlpHeader* other);

  // implements Message ----------------------------------------------

  inline NlpHeader* New() const { return New(NULL); }

  NlpHeader* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NlpHeader& from);
  void MergeFrom(const NlpHeader& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NlpHeader* other);
  void UnsafeMergeFrom(const NlpHeader& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional string lang = 2;
  void clear_lang();
  static const int kLangFieldNumber = 2;
  const ::std::string& lang() const;
  void set_lang(const ::std::string& value);
  void set_lang(const char* value);
  void set_lang(const char* value, size_t size);
  ::std::string* mutable_lang();
  ::std::string* release_lang();
  void set_allocated_lang(::std::string* lang);

  // optional string cdomain = 3;
  void clear_cdomain();
  static const int kCdomainFieldNumber = 3;
  const ::std::string& cdomain() const;
  void set_cdomain(const ::std::string& value);
  void set_cdomain(const char* value);
  void set_cdomain(const char* value, size_t size);
  ::std::string* mutable_cdomain();
  ::std::string* release_cdomain();
  void set_allocated_cdomain(::std::string* cdomain);

  // @@protoc_insertion_point(class_scope:rokid.open.NlpHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr lang_;
  ::google::protobuf::internal::ArenaStringPtr cdomain_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_speech_2eproto_impl();
  friend void  protobuf_AddDesc_speech_2eproto_impl();
  friend void protobuf_AssignDesc_speech_2eproto();
  friend void protobuf_ShutdownFile_speech_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<NlpHeader> NlpHeader_default_instance_;

// -------------------------------------------------------------------

class NlpResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rokid.open.NlpResponse) */ {
 public:
  NlpResponse();
  virtual ~NlpResponse();

  NlpResponse(const NlpResponse& from);

  inline NlpResponse& operator=(const NlpResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const NlpResponse& default_instance();

  static const NlpResponse* internal_default_instance();

  void Swap(NlpResponse* other);

  // implements Message ----------------------------------------------

  inline NlpResponse* New() const { return New(NULL); }

  NlpResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const NlpResponse& from);
  void MergeFrom(const NlpResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NlpResponse* other);
  void UnsafeMergeFrom(const NlpResponse& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string nlp = 1;
  void clear_nlp();
  static const int kNlpFieldNumber = 1;
  const ::std::string& nlp() const;
  void set_nlp(const ::std::string& value);
  void set_nlp(const char* value);
  void set_nlp(const char* value, size_t size);
  ::std::string* mutable_nlp();
  ::std::string* release_nlp();
  void set_allocated_nlp(::std::string* nlp);

  // @@protoc_insertion_point(class_scope:rokid.open.NlpResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr nlp_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_speech_2eproto_impl();
  friend void  protobuf_AddDesc_speech_2eproto_impl();
  friend void protobuf_AssignDesc_speech_2eproto();
  friend void protobuf_ShutdownFile_speech_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<NlpResponse> NlpResponse_default_instance_;

// -------------------------------------------------------------------

class TtsRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rokid.open.TtsRequest) */ {
 public:
  TtsRequest();
  virtual ~TtsRequest();

  TtsRequest(const TtsRequest& from);

  inline TtsRequest& operator=(const TtsRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TtsRequest& default_instance();

  static const TtsRequest* internal_default_instance();

  void Swap(TtsRequest* other);

  // implements Message ----------------------------------------------

  inline TtsRequest* New() const { return New(NULL); }

  TtsRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TtsRequest& from);
  void MergeFrom(const TtsRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TtsRequest* other);
  void UnsafeMergeFrom(const TtsRequest& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .rokid.open.TtsHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::rokid::open::TtsHeader& header() const;
  ::rokid::open::TtsHeader* mutable_header();
  ::rokid::open::TtsHeader* release_header();
  void set_allocated_header(::rokid::open::TtsHeader* header);

  // optional string text = 2;
  void clear_text();
  static const int kTextFieldNumber = 2;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // @@protoc_insertion_point(class_scope:rokid.open.TtsRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::rokid::open::TtsHeader* header_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_speech_2eproto_impl();
  friend void  protobuf_AddDesc_speech_2eproto_impl();
  friend void protobuf_AssignDesc_speech_2eproto();
  friend void protobuf_ShutdownFile_speech_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TtsRequest> TtsRequest_default_instance_;

// -------------------------------------------------------------------

class TtsHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rokid.open.TtsHeader) */ {
 public:
  TtsHeader();
  virtual ~TtsHeader();

  TtsHeader(const TtsHeader& from);

  inline TtsHeader& operator=(const TtsHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TtsHeader& default_instance();

  static const TtsHeader* internal_default_instance();

  void Swap(TtsHeader* other);

  // implements Message ----------------------------------------------

  inline TtsHeader* New() const { return New(NULL); }

  TtsHeader* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TtsHeader& from);
  void MergeFrom(const TtsHeader& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TtsHeader* other);
  void UnsafeMergeFrom(const TtsHeader& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional string declaimer = 2;
  void clear_declaimer();
  static const int kDeclaimerFieldNumber = 2;
  const ::std::string& declaimer() const;
  void set_declaimer(const ::std::string& value);
  void set_declaimer(const char* value);
  void set_declaimer(const char* value, size_t size);
  ::std::string* mutable_declaimer();
  ::std::string* release_declaimer();
  void set_allocated_declaimer(::std::string* declaimer);

  // optional string codec = 3;
  void clear_codec();
  static const int kCodecFieldNumber = 3;
  const ::std::string& codec() const;
  void set_codec(const ::std::string& value);
  void set_codec(const char* value);
  void set_codec(const char* value, size_t size);
  ::std::string* mutable_codec();
  ::std::string* release_codec();
  void set_allocated_codec(::std::string* codec);

  // @@protoc_insertion_point(class_scope:rokid.open.TtsHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr declaimer_;
  ::google::protobuf::internal::ArenaStringPtr codec_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_speech_2eproto_impl();
  friend void  protobuf_AddDesc_speech_2eproto_impl();
  friend void protobuf_AssignDesc_speech_2eproto();
  friend void protobuf_ShutdownFile_speech_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TtsHeader> TtsHeader_default_instance_;

// -------------------------------------------------------------------

class TtsResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rokid.open.TtsResponse) */ {
 public:
  TtsResponse();
  virtual ~TtsResponse();

  TtsResponse(const TtsResponse& from);

  inline TtsResponse& operator=(const TtsResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TtsResponse& default_instance();

  static const TtsResponse* internal_default_instance();

  void Swap(TtsResponse* other);

  // implements Message ----------------------------------------------

  inline TtsResponse* New() const { return New(NULL); }

  TtsResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TtsResponse& from);
  void MergeFrom(const TtsResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TtsResponse* other);
  void UnsafeMergeFrom(const TtsResponse& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string text = 1;
  void clear_text();
  static const int kTextFieldNumber = 1;
  const ::std::string& text() const;
  void set_text(const ::std::string& value);
  void set_text(const char* value);
  void set_text(const char* value, size_t size);
  ::std::string* mutable_text();
  ::std::string* release_text();
  void set_allocated_text(::std::string* text);

  // optional bytes voice = 2;
  void clear_voice();
  static const int kVoiceFieldNumber = 2;
  const ::std::string& voice() const;
  void set_voice(const ::std::string& value);
  void set_voice(const char* value);
  void set_voice(const void* value, size_t size);
  ::std::string* mutable_voice();
  ::std::string* release_voice();
  void set_allocated_voice(::std::string* voice);

  // @@protoc_insertion_point(class_scope:rokid.open.TtsResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr text_;
  ::google::protobuf::internal::ArenaStringPtr voice_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_speech_2eproto_impl();
  friend void  protobuf_AddDesc_speech_2eproto_impl();
  friend void protobuf_AssignDesc_speech_2eproto();
  friend void protobuf_ShutdownFile_speech_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TtsResponse> TtsResponse_default_instance_;

// -------------------------------------------------------------------

class VoiceSpeechRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rokid.open.VoiceSpeechRequest) */ {
 public:
  VoiceSpeechRequest();
  virtual ~VoiceSpeechRequest();

  VoiceSpeechRequest(const VoiceSpeechRequest& from);

  inline VoiceSpeechRequest& operator=(const VoiceSpeechRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VoiceSpeechRequest& default_instance();

  enum RequestContentCase {
    kHeader = 1,
    kVoice = 2,
    REQUEST_CONTENT_NOT_SET = 0,
  };

  static const VoiceSpeechRequest* internal_default_instance();

  void Swap(VoiceSpeechRequest* other);

  // implements Message ----------------------------------------------

  inline VoiceSpeechRequest* New() const { return New(NULL); }

  VoiceSpeechRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VoiceSpeechRequest& from);
  void MergeFrom(const VoiceSpeechRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VoiceSpeechRequest* other);
  void UnsafeMergeFrom(const VoiceSpeechRequest& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .rokid.open.SpeechHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::rokid::open::SpeechHeader& header() const;
  ::rokid::open::SpeechHeader* mutable_header();
  ::rokid::open::SpeechHeader* release_header();
  void set_allocated_header(::rokid::open::SpeechHeader* header);

  // optional bytes voice = 2;
  private:
  bool has_voice() const;
  public:
  void clear_voice();
  static const int kVoiceFieldNumber = 2;
  const ::std::string& voice() const;
  void set_voice(const ::std::string& value);
  void set_voice(const char* value);
  void set_voice(const void* value, size_t size);
  ::std::string* mutable_voice();
  ::std::string* release_voice();
  void set_allocated_voice(::std::string* voice);

  RequestContentCase request_content_case() const;
  // @@protoc_insertion_point(class_scope:rokid.open.VoiceSpeechRequest)
 private:
  inline void set_has_header();
  inline void set_has_voice();

  inline bool has_request_content() const;
  void clear_request_content();
  inline void clear_has_request_content();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  union RequestContentUnion {
    RequestContentUnion() {}
    ::rokid::open::SpeechHeader* header_;
    ::google::protobuf::internal::ArenaStringPtr voice_;
  } request_content_;
  mutable int _cached_size_;
  ::google::protobuf::uint32 _oneof_case_[1];

  friend void  protobuf_InitDefaults_speech_2eproto_impl();
  friend void  protobuf_AddDesc_speech_2eproto_impl();
  friend void protobuf_AssignDesc_speech_2eproto();
  friend void protobuf_ShutdownFile_speech_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<VoiceSpeechRequest> VoiceSpeechRequest_default_instance_;

// -------------------------------------------------------------------

class VoiceSpeechResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rokid.open.VoiceSpeechResponse) */ {
 public:
  VoiceSpeechResponse();
  virtual ~VoiceSpeechResponse();

  VoiceSpeechResponse(const VoiceSpeechResponse& from);

  inline VoiceSpeechResponse& operator=(const VoiceSpeechResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const VoiceSpeechResponse& default_instance();

  static const VoiceSpeechResponse* internal_default_instance();

  void Swap(VoiceSpeechResponse* other);

  // implements Message ----------------------------------------------

  inline VoiceSpeechResponse* New() const { return New(NULL); }

  VoiceSpeechResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const VoiceSpeechResponse& from);
  void MergeFrom(const VoiceSpeechResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(VoiceSpeechResponse* other);
  void UnsafeMergeFrom(const VoiceSpeechResponse& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string asr = 1;
  void clear_asr();
  static const int kAsrFieldNumber = 1;
  const ::std::string& asr() const;
  void set_asr(const ::std::string& value);
  void set_asr(const char* value);
  void set_asr(const char* value, size_t size);
  ::std::string* mutable_asr();
  ::std::string* release_asr();
  void set_allocated_asr(::std::string* asr);

  // optional string nlp = 2;
  void clear_nlp();
  static const int kNlpFieldNumber = 2;
  const ::std::string& nlp() const;
  void set_nlp(const ::std::string& value);
  void set_nlp(const char* value);
  void set_nlp(const char* value, size_t size);
  ::std::string* mutable_nlp();
  ::std::string* release_nlp();
  void set_allocated_nlp(::std::string* nlp);

  // optional string action = 3;
  void clear_action();
  static const int kActionFieldNumber = 3;
  const ::std::string& action() const;
  void set_action(const ::std::string& value);
  void set_action(const char* value);
  void set_action(const char* value, size_t size);
  ::std::string* mutable_action();
  ::std::string* release_action();
  void set_allocated_action(::std::string* action);

  // @@protoc_insertion_point(class_scope:rokid.open.VoiceSpeechResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr asr_;
  ::google::protobuf::internal::ArenaStringPtr nlp_;
  ::google::protobuf::internal::ArenaStringPtr action_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_speech_2eproto_impl();
  friend void  protobuf_AddDesc_speech_2eproto_impl();
  friend void protobuf_AssignDesc_speech_2eproto();
  friend void protobuf_ShutdownFile_speech_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<VoiceSpeechResponse> VoiceSpeechResponse_default_instance_;

// -------------------------------------------------------------------

class TextSpeechRequest : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rokid.open.TextSpeechRequest) */ {
 public:
  TextSpeechRequest();
  virtual ~TextSpeechRequest();

  TextSpeechRequest(const TextSpeechRequest& from);

  inline TextSpeechRequest& operator=(const TextSpeechRequest& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextSpeechRequest& default_instance();

  static const TextSpeechRequest* internal_default_instance();

  void Swap(TextSpeechRequest* other);

  // implements Message ----------------------------------------------

  inline TextSpeechRequest* New() const { return New(NULL); }

  TextSpeechRequest* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TextSpeechRequest& from);
  void MergeFrom(const TextSpeechRequest& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TextSpeechRequest* other);
  void UnsafeMergeFrom(const TextSpeechRequest& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .rokid.open.SpeechHeader header = 1;
  bool has_header() const;
  void clear_header();
  static const int kHeaderFieldNumber = 1;
  const ::rokid::open::SpeechHeader& header() const;
  ::rokid::open::SpeechHeader* mutable_header();
  ::rokid::open::SpeechHeader* release_header();
  void set_allocated_header(::rokid::open::SpeechHeader* header);

  // optional string asr = 2;
  void clear_asr();
  static const int kAsrFieldNumber = 2;
  const ::std::string& asr() const;
  void set_asr(const ::std::string& value);
  void set_asr(const char* value);
  void set_asr(const char* value, size_t size);
  ::std::string* mutable_asr();
  ::std::string* release_asr();
  void set_allocated_asr(::std::string* asr);

  // @@protoc_insertion_point(class_scope:rokid.open.TextSpeechRequest)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr asr_;
  ::rokid::open::SpeechHeader* header_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_speech_2eproto_impl();
  friend void  protobuf_AddDesc_speech_2eproto_impl();
  friend void protobuf_AssignDesc_speech_2eproto();
  friend void protobuf_ShutdownFile_speech_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TextSpeechRequest> TextSpeechRequest_default_instance_;

// -------------------------------------------------------------------

class TextSpeechResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rokid.open.TextSpeechResponse) */ {
 public:
  TextSpeechResponse();
  virtual ~TextSpeechResponse();

  TextSpeechResponse(const TextSpeechResponse& from);

  inline TextSpeechResponse& operator=(const TextSpeechResponse& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const TextSpeechResponse& default_instance();

  static const TextSpeechResponse* internal_default_instance();

  void Swap(TextSpeechResponse* other);

  // implements Message ----------------------------------------------

  inline TextSpeechResponse* New() const { return New(NULL); }

  TextSpeechResponse* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const TextSpeechResponse& from);
  void MergeFrom(const TextSpeechResponse& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TextSpeechResponse* other);
  void UnsafeMergeFrom(const TextSpeechResponse& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string asr = 1;
  void clear_asr();
  static const int kAsrFieldNumber = 1;
  const ::std::string& asr() const;
  void set_asr(const ::std::string& value);
  void set_asr(const char* value);
  void set_asr(const char* value, size_t size);
  ::std::string* mutable_asr();
  ::std::string* release_asr();
  void set_allocated_asr(::std::string* asr);

  // optional string nlp = 2;
  void clear_nlp();
  static const int kNlpFieldNumber = 2;
  const ::std::string& nlp() const;
  void set_nlp(const ::std::string& value);
  void set_nlp(const char* value);
  void set_nlp(const char* value, size_t size);
  ::std::string* mutable_nlp();
  ::std::string* release_nlp();
  void set_allocated_nlp(::std::string* nlp);

  // optional string action = 3;
  void clear_action();
  static const int kActionFieldNumber = 3;
  const ::std::string& action() const;
  void set_action(const ::std::string& value);
  void set_action(const char* value);
  void set_action(const char* value, size_t size);
  ::std::string* mutable_action();
  ::std::string* release_action();
  void set_allocated_action(::std::string* action);

  // @@protoc_insertion_point(class_scope:rokid.open.TextSpeechResponse)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr asr_;
  ::google::protobuf::internal::ArenaStringPtr nlp_;
  ::google::protobuf::internal::ArenaStringPtr action_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_speech_2eproto_impl();
  friend void  protobuf_AddDesc_speech_2eproto_impl();
  friend void protobuf_AssignDesc_speech_2eproto();
  friend void protobuf_ShutdownFile_speech_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<TextSpeechResponse> TextSpeechResponse_default_instance_;

// -------------------------------------------------------------------

class SpeechHeader : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:rokid.open.SpeechHeader) */ {
 public:
  SpeechHeader();
  virtual ~SpeechHeader();

  SpeechHeader(const SpeechHeader& from);

  inline SpeechHeader& operator=(const SpeechHeader& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const SpeechHeader& default_instance();

  static const SpeechHeader* internal_default_instance();

  void Swap(SpeechHeader* other);

  // implements Message ----------------------------------------------

  inline SpeechHeader* New() const { return New(NULL); }

  SpeechHeader* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const SpeechHeader& from);
  void MergeFrom(const SpeechHeader& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(SpeechHeader* other);
  void UnsafeMergeFrom(const SpeechHeader& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional string language = 2;
  void clear_language();
  static const int kLanguageFieldNumber = 2;
  const ::std::string& language() const;
  void set_language(const ::std::string& value);
  void set_language(const char* value);
  void set_language(const char* value, size_t size);
  ::std::string* mutable_language();
  ::std::string* release_language();
  void set_allocated_language(::std::string* language);

  // optional string codec = 3;
  void clear_codec();
  static const int kCodecFieldNumber = 3;
  const ::std::string& codec() const;
  void set_codec(const ::std::string& value);
  void set_codec(const char* value);
  void set_codec(const char* value, size_t size);
  ::std::string* mutable_codec();
  ::std::string* release_codec();
  void set_allocated_codec(::std::string* codec);

  // optional string vt = 4;
  void clear_vt();
  static const int kVtFieldNumber = 4;
  const ::std::string& vt() const;
  void set_vt(const ::std::string& value);
  void set_vt(const char* value);
  void set_vt(const char* value, size_t size);
  ::std::string* mutable_vt();
  ::std::string* release_vt();
  void set_allocated_vt(::std::string* vt);

  // optional string cdomain = 5;
  void clear_cdomain();
  static const int kCdomainFieldNumber = 5;
  const ::std::string& cdomain() const;
  void set_cdomain(const ::std::string& value);
  void set_cdomain(const char* value);
  void set_cdomain(const char* value, size_t size);
  ::std::string* mutable_cdomain();
  ::std::string* release_cdomain();
  void set_allocated_cdomain(::std::string* cdomain);

  // optional string device = 6;
  void clear_device();
  static const int kDeviceFieldNumber = 6;
  const ::std::string& device() const;
  void set_device(const ::std::string& value);
  void set_device(const char* value);
  void set_device(const char* value, size_t size);
  ::std::string* mutable_device();
  ::std::string* release_device();
  void set_allocated_device(::std::string* device);

  // @@protoc_insertion_point(class_scope:rokid.open.SpeechHeader)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr language_;
  ::google::protobuf::internal::ArenaStringPtr codec_;
  ::google::protobuf::internal::ArenaStringPtr vt_;
  ::google::protobuf::internal::ArenaStringPtr cdomain_;
  ::google::protobuf::internal::ArenaStringPtr device_;
  ::google::protobuf::int32 id_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_speech_2eproto_impl();
  friend void  protobuf_AddDesc_speech_2eproto_impl();
  friend void protobuf_AssignDesc_speech_2eproto();
  friend void protobuf_ShutdownFile_speech_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<SpeechHeader> SpeechHeader_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// AsrRequest

// optional .rokid.open.AsrHeader header = 1;
inline bool AsrRequest::has_header() const {
  return request_content_case() == kHeader;
}
inline void AsrRequest::set_has_header() {
  _oneof_case_[0] = kHeader;
}
inline void AsrRequest::clear_header() {
  if (has_header()) {
    delete request_content_.header_;
    clear_has_request_content();
  }
}
inline  const ::rokid::open::AsrHeader& AsrRequest::header() const {
  // @@protoc_insertion_point(field_get:rokid.open.AsrRequest.header)
  return has_header()
      ? *request_content_.header_
      : ::rokid::open::AsrHeader::default_instance();
}
inline ::rokid::open::AsrHeader* AsrRequest::mutable_header() {
  if (!has_header()) {
    clear_request_content();
    set_has_header();
    request_content_.header_ = new ::rokid::open::AsrHeader;
  }
  // @@protoc_insertion_point(field_mutable:rokid.open.AsrRequest.header)
  return request_content_.header_;
}
inline ::rokid::open::AsrHeader* AsrRequest::release_header() {
  // @@protoc_insertion_point(field_release:rokid.open.AsrRequest.header)
  if (has_header()) {
    clear_has_request_content();
    ::rokid::open::AsrHeader* temp = request_content_.header_;
    request_content_.header_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void AsrRequest::set_allocated_header(::rokid::open::AsrHeader* header) {
  clear_request_content();
  if (header) {
    set_has_header();
    request_content_.header_ = header;
  }
  // @@protoc_insertion_point(field_set_allocated:rokid.open.AsrRequest.header)
}

// optional bytes voice = 2;
inline bool AsrRequest::has_voice() const {
  return request_content_case() == kVoice;
}
inline void AsrRequest::set_has_voice() {
  _oneof_case_[0] = kVoice;
}
inline void AsrRequest::clear_voice() {
  if (has_voice()) {
    request_content_.voice_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_request_content();
  }
}
inline const ::std::string& AsrRequest::voice() const {
  // @@protoc_insertion_point(field_get:rokid.open.AsrRequest.voice)
  if (has_voice()) {
    return request_content_.voice_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void AsrRequest::set_voice(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:rokid.open.AsrRequest.voice)
  if (!has_voice()) {
    clear_request_content();
    set_has_voice();
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  request_content_.voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.AsrRequest.voice)
}
inline void AsrRequest::set_voice(const char* value) {
  if (!has_voice()) {
    clear_request_content();
    set_has_voice();
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  request_content_.voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.AsrRequest.voice)
}
inline void AsrRequest::set_voice(const void* value, size_t size) {
  if (!has_voice()) {
    clear_request_content();
    set_has_voice();
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  request_content_.voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.AsrRequest.voice)
}
inline ::std::string* AsrRequest::mutable_voice() {
  if (!has_voice()) {
    clear_request_content();
    set_has_voice();
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:rokid.open.AsrRequest.voice)
  return request_content_.voice_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AsrRequest::release_voice() {
  // @@protoc_insertion_point(field_release:rokid.open.AsrRequest.voice)
  if (has_voice()) {
    clear_has_request_content();
    return request_content_.voice_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void AsrRequest::set_allocated_voice(::std::string* voice) {
  if (!has_voice()) {
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_request_content();
  if (voice != NULL) {
    set_has_voice();
    request_content_.voice_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        voice);
  }
  // @@protoc_insertion_point(field_set_allocated:rokid.open.AsrRequest.voice)
}

inline bool AsrRequest::has_request_content() const {
  return request_content_case() != REQUEST_CONTENT_NOT_SET;
}
inline void AsrRequest::clear_has_request_content() {
  _oneof_case_[0] = REQUEST_CONTENT_NOT_SET;
}
inline AsrRequest::RequestContentCase AsrRequest::request_content_case() const {
  return AsrRequest::RequestContentCase(_oneof_case_[0]);
}
inline const AsrRequest* AsrRequest::internal_default_instance() {
  return &AsrRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// AsrHeader

// optional int32 id = 1;
inline void AsrHeader::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 AsrHeader::id() const {
  // @@protoc_insertion_point(field_get:rokid.open.AsrHeader.id)
  return id_;
}
inline void AsrHeader::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:rokid.open.AsrHeader.id)
}

// optional string lang = 2;
inline void AsrHeader::clear_lang() {
  lang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AsrHeader::lang() const {
  // @@protoc_insertion_point(field_get:rokid.open.AsrHeader.lang)
  return lang_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AsrHeader::set_lang(const ::std::string& value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.AsrHeader.lang)
}
inline void AsrHeader::set_lang(const char* value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.AsrHeader.lang)
}
inline void AsrHeader::set_lang(const char* value, size_t size) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.AsrHeader.lang)
}
inline ::std::string* AsrHeader::mutable_lang() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.AsrHeader.lang)
  return lang_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AsrHeader::release_lang() {
  // @@protoc_insertion_point(field_release:rokid.open.AsrHeader.lang)
  
  return lang_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AsrHeader::set_allocated_lang(::std::string* lang) {
  if (lang != NULL) {
    
  } else {
    
  }
  lang_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lang);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.AsrHeader.lang)
}

// optional string codec = 3;
inline void AsrHeader::clear_codec() {
  codec_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AsrHeader::codec() const {
  // @@protoc_insertion_point(field_get:rokid.open.AsrHeader.codec)
  return codec_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AsrHeader::set_codec(const ::std::string& value) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.AsrHeader.codec)
}
inline void AsrHeader::set_codec(const char* value) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.AsrHeader.codec)
}
inline void AsrHeader::set_codec(const char* value, size_t size) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.AsrHeader.codec)
}
inline ::std::string* AsrHeader::mutable_codec() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.AsrHeader.codec)
  return codec_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AsrHeader::release_codec() {
  // @@protoc_insertion_point(field_release:rokid.open.AsrHeader.codec)
  
  return codec_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AsrHeader::set_allocated_codec(::std::string* codec) {
  if (codec != NULL) {
    
  } else {
    
  }
  codec_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codec);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.AsrHeader.codec)
}

// optional string vt = 4;
inline void AsrHeader::clear_vt() {
  vt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AsrHeader::vt() const {
  // @@protoc_insertion_point(field_get:rokid.open.AsrHeader.vt)
  return vt_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AsrHeader::set_vt(const ::std::string& value) {
  
  vt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.AsrHeader.vt)
}
inline void AsrHeader::set_vt(const char* value) {
  
  vt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.AsrHeader.vt)
}
inline void AsrHeader::set_vt(const char* value, size_t size) {
  
  vt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.AsrHeader.vt)
}
inline ::std::string* AsrHeader::mutable_vt() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.AsrHeader.vt)
  return vt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AsrHeader::release_vt() {
  // @@protoc_insertion_point(field_release:rokid.open.AsrHeader.vt)
  
  return vt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AsrHeader::set_allocated_vt(::std::string* vt) {
  if (vt != NULL) {
    
  } else {
    
  }
  vt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vt);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.AsrHeader.vt)
}

inline const AsrHeader* AsrHeader::internal_default_instance() {
  return &AsrHeader_default_instance_.get();
}
// -------------------------------------------------------------------

// AsrResponse

// optional string asr = 1;
inline void AsrResponse::clear_asr() {
  asr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& AsrResponse::asr() const {
  // @@protoc_insertion_point(field_get:rokid.open.AsrResponse.asr)
  return asr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AsrResponse::set_asr(const ::std::string& value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.AsrResponse.asr)
}
inline void AsrResponse::set_asr(const char* value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.AsrResponse.asr)
}
inline void AsrResponse::set_asr(const char* value, size_t size) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.AsrResponse.asr)
}
inline ::std::string* AsrResponse::mutable_asr() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.AsrResponse.asr)
  return asr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AsrResponse::release_asr() {
  // @@protoc_insertion_point(field_release:rokid.open.AsrResponse.asr)
  
  return asr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AsrResponse::set_allocated_asr(::std::string* asr) {
  if (asr != NULL) {
    
  } else {
    
  }
  asr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asr);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.AsrResponse.asr)
}

inline const AsrResponse* AsrResponse::internal_default_instance() {
  return &AsrResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// NlpRequest

// optional .rokid.open.NlpHeader header = 1;
inline bool NlpRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void NlpRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::rokid::open::NlpHeader& NlpRequest::header() const {
  // @@protoc_insertion_point(field_get:rokid.open.NlpRequest.header)
  return header_ != NULL ? *header_
                         : *::rokid::open::NlpHeader::internal_default_instance();
}
inline ::rokid::open::NlpHeader* NlpRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::rokid::open::NlpHeader;
  }
  // @@protoc_insertion_point(field_mutable:rokid.open.NlpRequest.header)
  return header_;
}
inline ::rokid::open::NlpHeader* NlpRequest::release_header() {
  // @@protoc_insertion_point(field_release:rokid.open.NlpRequest.header)
  
  ::rokid::open::NlpHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void NlpRequest::set_allocated_header(::rokid::open::NlpHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rokid.open.NlpRequest.header)
}

// optional string asr = 2;
inline void NlpRequest::clear_asr() {
  asr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NlpRequest::asr() const {
  // @@protoc_insertion_point(field_get:rokid.open.NlpRequest.asr)
  return asr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NlpRequest::set_asr(const ::std::string& value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.NlpRequest.asr)
}
inline void NlpRequest::set_asr(const char* value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.NlpRequest.asr)
}
inline void NlpRequest::set_asr(const char* value, size_t size) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.NlpRequest.asr)
}
inline ::std::string* NlpRequest::mutable_asr() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.NlpRequest.asr)
  return asr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NlpRequest::release_asr() {
  // @@protoc_insertion_point(field_release:rokid.open.NlpRequest.asr)
  
  return asr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NlpRequest::set_allocated_asr(::std::string* asr) {
  if (asr != NULL) {
    
  } else {
    
  }
  asr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asr);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.NlpRequest.asr)
}

inline const NlpRequest* NlpRequest::internal_default_instance() {
  return &NlpRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// NlpHeader

// optional int32 id = 1;
inline void NlpHeader::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 NlpHeader::id() const {
  // @@protoc_insertion_point(field_get:rokid.open.NlpHeader.id)
  return id_;
}
inline void NlpHeader::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:rokid.open.NlpHeader.id)
}

// optional string lang = 2;
inline void NlpHeader::clear_lang() {
  lang_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NlpHeader::lang() const {
  // @@protoc_insertion_point(field_get:rokid.open.NlpHeader.lang)
  return lang_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NlpHeader::set_lang(const ::std::string& value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.NlpHeader.lang)
}
inline void NlpHeader::set_lang(const char* value) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.NlpHeader.lang)
}
inline void NlpHeader::set_lang(const char* value, size_t size) {
  
  lang_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.NlpHeader.lang)
}
inline ::std::string* NlpHeader::mutable_lang() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.NlpHeader.lang)
  return lang_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NlpHeader::release_lang() {
  // @@protoc_insertion_point(field_release:rokid.open.NlpHeader.lang)
  
  return lang_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NlpHeader::set_allocated_lang(::std::string* lang) {
  if (lang != NULL) {
    
  } else {
    
  }
  lang_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lang);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.NlpHeader.lang)
}

// optional string cdomain = 3;
inline void NlpHeader::clear_cdomain() {
  cdomain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NlpHeader::cdomain() const {
  // @@protoc_insertion_point(field_get:rokid.open.NlpHeader.cdomain)
  return cdomain_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NlpHeader::set_cdomain(const ::std::string& value) {
  
  cdomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.NlpHeader.cdomain)
}
inline void NlpHeader::set_cdomain(const char* value) {
  
  cdomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.NlpHeader.cdomain)
}
inline void NlpHeader::set_cdomain(const char* value, size_t size) {
  
  cdomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.NlpHeader.cdomain)
}
inline ::std::string* NlpHeader::mutable_cdomain() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.NlpHeader.cdomain)
  return cdomain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NlpHeader::release_cdomain() {
  // @@protoc_insertion_point(field_release:rokid.open.NlpHeader.cdomain)
  
  return cdomain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NlpHeader::set_allocated_cdomain(::std::string* cdomain) {
  if (cdomain != NULL) {
    
  } else {
    
  }
  cdomain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cdomain);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.NlpHeader.cdomain)
}

inline const NlpHeader* NlpHeader::internal_default_instance() {
  return &NlpHeader_default_instance_.get();
}
// -------------------------------------------------------------------

// NlpResponse

// optional string nlp = 1;
inline void NlpResponse::clear_nlp() {
  nlp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& NlpResponse::nlp() const {
  // @@protoc_insertion_point(field_get:rokid.open.NlpResponse.nlp)
  return nlp_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NlpResponse::set_nlp(const ::std::string& value) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.NlpResponse.nlp)
}
inline void NlpResponse::set_nlp(const char* value) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.NlpResponse.nlp)
}
inline void NlpResponse::set_nlp(const char* value, size_t size) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.NlpResponse.nlp)
}
inline ::std::string* NlpResponse::mutable_nlp() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.NlpResponse.nlp)
  return nlp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* NlpResponse::release_nlp() {
  // @@protoc_insertion_point(field_release:rokid.open.NlpResponse.nlp)
  
  return nlp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void NlpResponse::set_allocated_nlp(::std::string* nlp) {
  if (nlp != NULL) {
    
  } else {
    
  }
  nlp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nlp);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.NlpResponse.nlp)
}

inline const NlpResponse* NlpResponse::internal_default_instance() {
  return &NlpResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// TtsRequest

// optional .rokid.open.TtsHeader header = 1;
inline bool TtsRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void TtsRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::rokid::open::TtsHeader& TtsRequest::header() const {
  // @@protoc_insertion_point(field_get:rokid.open.TtsRequest.header)
  return header_ != NULL ? *header_
                         : *::rokid::open::TtsHeader::internal_default_instance();
}
inline ::rokid::open::TtsHeader* TtsRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::rokid::open::TtsHeader;
  }
  // @@protoc_insertion_point(field_mutable:rokid.open.TtsRequest.header)
  return header_;
}
inline ::rokid::open::TtsHeader* TtsRequest::release_header() {
  // @@protoc_insertion_point(field_release:rokid.open.TtsRequest.header)
  
  ::rokid::open::TtsHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void TtsRequest::set_allocated_header(::rokid::open::TtsHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TtsRequest.header)
}

// optional string text = 2;
inline void TtsRequest::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TtsRequest::text() const {
  // @@protoc_insertion_point(field_get:rokid.open.TtsRequest.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TtsRequest::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TtsRequest.text)
}
inline void TtsRequest::set_text(const char* value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TtsRequest.text)
}
inline void TtsRequest::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TtsRequest.text)
}
inline ::std::string* TtsRequest::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TtsRequest.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TtsRequest::release_text() {
  // @@protoc_insertion_point(field_release:rokid.open.TtsRequest.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TtsRequest::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TtsRequest.text)
}

inline const TtsRequest* TtsRequest::internal_default_instance() {
  return &TtsRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// TtsHeader

// optional int32 id = 1;
inline void TtsHeader::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 TtsHeader::id() const {
  // @@protoc_insertion_point(field_get:rokid.open.TtsHeader.id)
  return id_;
}
inline void TtsHeader::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:rokid.open.TtsHeader.id)
}

// optional string declaimer = 2;
inline void TtsHeader::clear_declaimer() {
  declaimer_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TtsHeader::declaimer() const {
  // @@protoc_insertion_point(field_get:rokid.open.TtsHeader.declaimer)
  return declaimer_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TtsHeader::set_declaimer(const ::std::string& value) {
  
  declaimer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TtsHeader.declaimer)
}
inline void TtsHeader::set_declaimer(const char* value) {
  
  declaimer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TtsHeader.declaimer)
}
inline void TtsHeader::set_declaimer(const char* value, size_t size) {
  
  declaimer_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TtsHeader.declaimer)
}
inline ::std::string* TtsHeader::mutable_declaimer() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TtsHeader.declaimer)
  return declaimer_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TtsHeader::release_declaimer() {
  // @@protoc_insertion_point(field_release:rokid.open.TtsHeader.declaimer)
  
  return declaimer_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TtsHeader::set_allocated_declaimer(::std::string* declaimer) {
  if (declaimer != NULL) {
    
  } else {
    
  }
  declaimer_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), declaimer);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TtsHeader.declaimer)
}

// optional string codec = 3;
inline void TtsHeader::clear_codec() {
  codec_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TtsHeader::codec() const {
  // @@protoc_insertion_point(field_get:rokid.open.TtsHeader.codec)
  return codec_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TtsHeader::set_codec(const ::std::string& value) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TtsHeader.codec)
}
inline void TtsHeader::set_codec(const char* value) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TtsHeader.codec)
}
inline void TtsHeader::set_codec(const char* value, size_t size) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TtsHeader.codec)
}
inline ::std::string* TtsHeader::mutable_codec() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TtsHeader.codec)
  return codec_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TtsHeader::release_codec() {
  // @@protoc_insertion_point(field_release:rokid.open.TtsHeader.codec)
  
  return codec_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TtsHeader::set_allocated_codec(::std::string* codec) {
  if (codec != NULL) {
    
  } else {
    
  }
  codec_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codec);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TtsHeader.codec)
}

inline const TtsHeader* TtsHeader::internal_default_instance() {
  return &TtsHeader_default_instance_.get();
}
// -------------------------------------------------------------------

// TtsResponse

// optional string text = 1;
inline void TtsResponse::clear_text() {
  text_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TtsResponse::text() const {
  // @@protoc_insertion_point(field_get:rokid.open.TtsResponse.text)
  return text_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TtsResponse::set_text(const ::std::string& value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TtsResponse.text)
}
inline void TtsResponse::set_text(const char* value) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TtsResponse.text)
}
inline void TtsResponse::set_text(const char* value, size_t size) {
  
  text_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TtsResponse.text)
}
inline ::std::string* TtsResponse::mutable_text() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TtsResponse.text)
  return text_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TtsResponse::release_text() {
  // @@protoc_insertion_point(field_release:rokid.open.TtsResponse.text)
  
  return text_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TtsResponse::set_allocated_text(::std::string* text) {
  if (text != NULL) {
    
  } else {
    
  }
  text_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), text);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TtsResponse.text)
}

// optional bytes voice = 2;
inline void TtsResponse::clear_voice() {
  voice_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TtsResponse::voice() const {
  // @@protoc_insertion_point(field_get:rokid.open.TtsResponse.voice)
  return voice_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TtsResponse::set_voice(const ::std::string& value) {
  
  voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TtsResponse.voice)
}
inline void TtsResponse::set_voice(const char* value) {
  
  voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TtsResponse.voice)
}
inline void TtsResponse::set_voice(const void* value, size_t size) {
  
  voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TtsResponse.voice)
}
inline ::std::string* TtsResponse::mutable_voice() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TtsResponse.voice)
  return voice_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TtsResponse::release_voice() {
  // @@protoc_insertion_point(field_release:rokid.open.TtsResponse.voice)
  
  return voice_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TtsResponse::set_allocated_voice(::std::string* voice) {
  if (voice != NULL) {
    
  } else {
    
  }
  voice_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), voice);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TtsResponse.voice)
}

inline const TtsResponse* TtsResponse::internal_default_instance() {
  return &TtsResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// VoiceSpeechRequest

// optional .rokid.open.SpeechHeader header = 1;
inline bool VoiceSpeechRequest::has_header() const {
  return request_content_case() == kHeader;
}
inline void VoiceSpeechRequest::set_has_header() {
  _oneof_case_[0] = kHeader;
}
inline void VoiceSpeechRequest::clear_header() {
  if (has_header()) {
    delete request_content_.header_;
    clear_has_request_content();
  }
}
inline  const ::rokid::open::SpeechHeader& VoiceSpeechRequest::header() const {
  // @@protoc_insertion_point(field_get:rokid.open.VoiceSpeechRequest.header)
  return has_header()
      ? *request_content_.header_
      : ::rokid::open::SpeechHeader::default_instance();
}
inline ::rokid::open::SpeechHeader* VoiceSpeechRequest::mutable_header() {
  if (!has_header()) {
    clear_request_content();
    set_has_header();
    request_content_.header_ = new ::rokid::open::SpeechHeader;
  }
  // @@protoc_insertion_point(field_mutable:rokid.open.VoiceSpeechRequest.header)
  return request_content_.header_;
}
inline ::rokid::open::SpeechHeader* VoiceSpeechRequest::release_header() {
  // @@protoc_insertion_point(field_release:rokid.open.VoiceSpeechRequest.header)
  if (has_header()) {
    clear_has_request_content();
    ::rokid::open::SpeechHeader* temp = request_content_.header_;
    request_content_.header_ = NULL;
    return temp;
  } else {
    return NULL;
  }
}
inline void VoiceSpeechRequest::set_allocated_header(::rokid::open::SpeechHeader* header) {
  clear_request_content();
  if (header) {
    set_has_header();
    request_content_.header_ = header;
  }
  // @@protoc_insertion_point(field_set_allocated:rokid.open.VoiceSpeechRequest.header)
}

// optional bytes voice = 2;
inline bool VoiceSpeechRequest::has_voice() const {
  return request_content_case() == kVoice;
}
inline void VoiceSpeechRequest::set_has_voice() {
  _oneof_case_[0] = kVoice;
}
inline void VoiceSpeechRequest::clear_voice() {
  if (has_voice()) {
    request_content_.voice_.DestroyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
    clear_has_request_content();
  }
}
inline const ::std::string& VoiceSpeechRequest::voice() const {
  // @@protoc_insertion_point(field_get:rokid.open.VoiceSpeechRequest.voice)
  if (has_voice()) {
    return request_content_.voice_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  return *&::google::protobuf::internal::GetEmptyStringAlreadyInited();
}
inline void VoiceSpeechRequest::set_voice(const ::std::string& value) {
  // @@protoc_insertion_point(field_set:rokid.open.VoiceSpeechRequest.voice)
  if (!has_voice()) {
    clear_request_content();
    set_has_voice();
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  request_content_.voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.VoiceSpeechRequest.voice)
}
inline void VoiceSpeechRequest::set_voice(const char* value) {
  if (!has_voice()) {
    clear_request_content();
    set_has_voice();
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  request_content_.voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.VoiceSpeechRequest.voice)
}
inline void VoiceSpeechRequest::set_voice(const void* value, size_t size) {
  if (!has_voice()) {
    clear_request_content();
    set_has_voice();
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  request_content_.voice_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(
      reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.VoiceSpeechRequest.voice)
}
inline ::std::string* VoiceSpeechRequest::mutable_voice() {
  if (!has_voice()) {
    clear_request_content();
    set_has_voice();
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  // @@protoc_insertion_point(field_mutable:rokid.open.VoiceSpeechRequest.voice)
  return request_content_.voice_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VoiceSpeechRequest::release_voice() {
  // @@protoc_insertion_point(field_release:rokid.open.VoiceSpeechRequest.voice)
  if (has_voice()) {
    clear_has_request_content();
    return request_content_.voice_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  } else {
    return NULL;
  }
}
inline void VoiceSpeechRequest::set_allocated_voice(::std::string* voice) {
  if (!has_voice()) {
    request_content_.voice_.UnsafeSetDefault(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  }
  clear_request_content();
  if (voice != NULL) {
    set_has_voice();
    request_content_.voice_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
        voice);
  }
  // @@protoc_insertion_point(field_set_allocated:rokid.open.VoiceSpeechRequest.voice)
}

inline bool VoiceSpeechRequest::has_request_content() const {
  return request_content_case() != REQUEST_CONTENT_NOT_SET;
}
inline void VoiceSpeechRequest::clear_has_request_content() {
  _oneof_case_[0] = REQUEST_CONTENT_NOT_SET;
}
inline VoiceSpeechRequest::RequestContentCase VoiceSpeechRequest::request_content_case() const {
  return VoiceSpeechRequest::RequestContentCase(_oneof_case_[0]);
}
inline const VoiceSpeechRequest* VoiceSpeechRequest::internal_default_instance() {
  return &VoiceSpeechRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// VoiceSpeechResponse

// optional string asr = 1;
inline void VoiceSpeechResponse::clear_asr() {
  asr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VoiceSpeechResponse::asr() const {
  // @@protoc_insertion_point(field_get:rokid.open.VoiceSpeechResponse.asr)
  return asr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VoiceSpeechResponse::set_asr(const ::std::string& value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.VoiceSpeechResponse.asr)
}
inline void VoiceSpeechResponse::set_asr(const char* value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.VoiceSpeechResponse.asr)
}
inline void VoiceSpeechResponse::set_asr(const char* value, size_t size) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.VoiceSpeechResponse.asr)
}
inline ::std::string* VoiceSpeechResponse::mutable_asr() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.VoiceSpeechResponse.asr)
  return asr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VoiceSpeechResponse::release_asr() {
  // @@protoc_insertion_point(field_release:rokid.open.VoiceSpeechResponse.asr)
  
  return asr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VoiceSpeechResponse::set_allocated_asr(::std::string* asr) {
  if (asr != NULL) {
    
  } else {
    
  }
  asr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asr);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.VoiceSpeechResponse.asr)
}

// optional string nlp = 2;
inline void VoiceSpeechResponse::clear_nlp() {
  nlp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VoiceSpeechResponse::nlp() const {
  // @@protoc_insertion_point(field_get:rokid.open.VoiceSpeechResponse.nlp)
  return nlp_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VoiceSpeechResponse::set_nlp(const ::std::string& value) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.VoiceSpeechResponse.nlp)
}
inline void VoiceSpeechResponse::set_nlp(const char* value) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.VoiceSpeechResponse.nlp)
}
inline void VoiceSpeechResponse::set_nlp(const char* value, size_t size) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.VoiceSpeechResponse.nlp)
}
inline ::std::string* VoiceSpeechResponse::mutable_nlp() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.VoiceSpeechResponse.nlp)
  return nlp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VoiceSpeechResponse::release_nlp() {
  // @@protoc_insertion_point(field_release:rokid.open.VoiceSpeechResponse.nlp)
  
  return nlp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VoiceSpeechResponse::set_allocated_nlp(::std::string* nlp) {
  if (nlp != NULL) {
    
  } else {
    
  }
  nlp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nlp);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.VoiceSpeechResponse.nlp)
}

// optional string action = 3;
inline void VoiceSpeechResponse::clear_action() {
  action_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& VoiceSpeechResponse::action() const {
  // @@protoc_insertion_point(field_get:rokid.open.VoiceSpeechResponse.action)
  return action_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VoiceSpeechResponse::set_action(const ::std::string& value) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.VoiceSpeechResponse.action)
}
inline void VoiceSpeechResponse::set_action(const char* value) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.VoiceSpeechResponse.action)
}
inline void VoiceSpeechResponse::set_action(const char* value, size_t size) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.VoiceSpeechResponse.action)
}
inline ::std::string* VoiceSpeechResponse::mutable_action() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.VoiceSpeechResponse.action)
  return action_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* VoiceSpeechResponse::release_action() {
  // @@protoc_insertion_point(field_release:rokid.open.VoiceSpeechResponse.action)
  
  return action_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void VoiceSpeechResponse::set_allocated_action(::std::string* action) {
  if (action != NULL) {
    
  } else {
    
  }
  action_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), action);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.VoiceSpeechResponse.action)
}

inline const VoiceSpeechResponse* VoiceSpeechResponse::internal_default_instance() {
  return &VoiceSpeechResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// TextSpeechRequest

// optional .rokid.open.SpeechHeader header = 1;
inline bool TextSpeechRequest::has_header() const {
  return this != internal_default_instance() && header_ != NULL;
}
inline void TextSpeechRequest::clear_header() {
  if (GetArenaNoVirtual() == NULL && header_ != NULL) delete header_;
  header_ = NULL;
}
inline const ::rokid::open::SpeechHeader& TextSpeechRequest::header() const {
  // @@protoc_insertion_point(field_get:rokid.open.TextSpeechRequest.header)
  return header_ != NULL ? *header_
                         : *::rokid::open::SpeechHeader::internal_default_instance();
}
inline ::rokid::open::SpeechHeader* TextSpeechRequest::mutable_header() {
  
  if (header_ == NULL) {
    header_ = new ::rokid::open::SpeechHeader;
  }
  // @@protoc_insertion_point(field_mutable:rokid.open.TextSpeechRequest.header)
  return header_;
}
inline ::rokid::open::SpeechHeader* TextSpeechRequest::release_header() {
  // @@protoc_insertion_point(field_release:rokid.open.TextSpeechRequest.header)
  
  ::rokid::open::SpeechHeader* temp = header_;
  header_ = NULL;
  return temp;
}
inline void TextSpeechRequest::set_allocated_header(::rokid::open::SpeechHeader* header) {
  delete header_;
  header_ = header;
  if (header) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TextSpeechRequest.header)
}

// optional string asr = 2;
inline void TextSpeechRequest::clear_asr() {
  asr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TextSpeechRequest::asr() const {
  // @@protoc_insertion_point(field_get:rokid.open.TextSpeechRequest.asr)
  return asr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextSpeechRequest::set_asr(const ::std::string& value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TextSpeechRequest.asr)
}
inline void TextSpeechRequest::set_asr(const char* value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TextSpeechRequest.asr)
}
inline void TextSpeechRequest::set_asr(const char* value, size_t size) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TextSpeechRequest.asr)
}
inline ::std::string* TextSpeechRequest::mutable_asr() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TextSpeechRequest.asr)
  return asr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextSpeechRequest::release_asr() {
  // @@protoc_insertion_point(field_release:rokid.open.TextSpeechRequest.asr)
  
  return asr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextSpeechRequest::set_allocated_asr(::std::string* asr) {
  if (asr != NULL) {
    
  } else {
    
  }
  asr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asr);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TextSpeechRequest.asr)
}

inline const TextSpeechRequest* TextSpeechRequest::internal_default_instance() {
  return &TextSpeechRequest_default_instance_.get();
}
// -------------------------------------------------------------------

// TextSpeechResponse

// optional string asr = 1;
inline void TextSpeechResponse::clear_asr() {
  asr_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TextSpeechResponse::asr() const {
  // @@protoc_insertion_point(field_get:rokid.open.TextSpeechResponse.asr)
  return asr_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextSpeechResponse::set_asr(const ::std::string& value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TextSpeechResponse.asr)
}
inline void TextSpeechResponse::set_asr(const char* value) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TextSpeechResponse.asr)
}
inline void TextSpeechResponse::set_asr(const char* value, size_t size) {
  
  asr_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TextSpeechResponse.asr)
}
inline ::std::string* TextSpeechResponse::mutable_asr() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TextSpeechResponse.asr)
  return asr_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextSpeechResponse::release_asr() {
  // @@protoc_insertion_point(field_release:rokid.open.TextSpeechResponse.asr)
  
  return asr_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextSpeechResponse::set_allocated_asr(::std::string* asr) {
  if (asr != NULL) {
    
  } else {
    
  }
  asr_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), asr);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TextSpeechResponse.asr)
}

// optional string nlp = 2;
inline void TextSpeechResponse::clear_nlp() {
  nlp_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TextSpeechResponse::nlp() const {
  // @@protoc_insertion_point(field_get:rokid.open.TextSpeechResponse.nlp)
  return nlp_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextSpeechResponse::set_nlp(const ::std::string& value) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TextSpeechResponse.nlp)
}
inline void TextSpeechResponse::set_nlp(const char* value) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TextSpeechResponse.nlp)
}
inline void TextSpeechResponse::set_nlp(const char* value, size_t size) {
  
  nlp_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TextSpeechResponse.nlp)
}
inline ::std::string* TextSpeechResponse::mutable_nlp() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TextSpeechResponse.nlp)
  return nlp_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextSpeechResponse::release_nlp() {
  // @@protoc_insertion_point(field_release:rokid.open.TextSpeechResponse.nlp)
  
  return nlp_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextSpeechResponse::set_allocated_nlp(::std::string* nlp) {
  if (nlp != NULL) {
    
  } else {
    
  }
  nlp_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nlp);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TextSpeechResponse.nlp)
}

// optional string action = 3;
inline void TextSpeechResponse::clear_action() {
  action_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& TextSpeechResponse::action() const {
  // @@protoc_insertion_point(field_get:rokid.open.TextSpeechResponse.action)
  return action_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextSpeechResponse::set_action(const ::std::string& value) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.TextSpeechResponse.action)
}
inline void TextSpeechResponse::set_action(const char* value) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.TextSpeechResponse.action)
}
inline void TextSpeechResponse::set_action(const char* value, size_t size) {
  
  action_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.TextSpeechResponse.action)
}
inline ::std::string* TextSpeechResponse::mutable_action() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.TextSpeechResponse.action)
  return action_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* TextSpeechResponse::release_action() {
  // @@protoc_insertion_point(field_release:rokid.open.TextSpeechResponse.action)
  
  return action_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void TextSpeechResponse::set_allocated_action(::std::string* action) {
  if (action != NULL) {
    
  } else {
    
  }
  action_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), action);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.TextSpeechResponse.action)
}

inline const TextSpeechResponse* TextSpeechResponse::internal_default_instance() {
  return &TextSpeechResponse_default_instance_.get();
}
// -------------------------------------------------------------------

// SpeechHeader

// optional int32 id = 1;
inline void SpeechHeader::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 SpeechHeader::id() const {
  // @@protoc_insertion_point(field_get:rokid.open.SpeechHeader.id)
  return id_;
}
inline void SpeechHeader::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:rokid.open.SpeechHeader.id)
}

// optional string language = 2;
inline void SpeechHeader::clear_language() {
  language_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SpeechHeader::language() const {
  // @@protoc_insertion_point(field_get:rokid.open.SpeechHeader.language)
  return language_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeechHeader::set_language(const ::std::string& value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.SpeechHeader.language)
}
inline void SpeechHeader::set_language(const char* value) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.SpeechHeader.language)
}
inline void SpeechHeader::set_language(const char* value, size_t size) {
  
  language_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.SpeechHeader.language)
}
inline ::std::string* SpeechHeader::mutable_language() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.SpeechHeader.language)
  return language_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpeechHeader::release_language() {
  // @@protoc_insertion_point(field_release:rokid.open.SpeechHeader.language)
  
  return language_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeechHeader::set_allocated_language(::std::string* language) {
  if (language != NULL) {
    
  } else {
    
  }
  language_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), language);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.SpeechHeader.language)
}

// optional string codec = 3;
inline void SpeechHeader::clear_codec() {
  codec_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SpeechHeader::codec() const {
  // @@protoc_insertion_point(field_get:rokid.open.SpeechHeader.codec)
  return codec_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeechHeader::set_codec(const ::std::string& value) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.SpeechHeader.codec)
}
inline void SpeechHeader::set_codec(const char* value) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.SpeechHeader.codec)
}
inline void SpeechHeader::set_codec(const char* value, size_t size) {
  
  codec_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.SpeechHeader.codec)
}
inline ::std::string* SpeechHeader::mutable_codec() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.SpeechHeader.codec)
  return codec_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpeechHeader::release_codec() {
  // @@protoc_insertion_point(field_release:rokid.open.SpeechHeader.codec)
  
  return codec_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeechHeader::set_allocated_codec(::std::string* codec) {
  if (codec != NULL) {
    
  } else {
    
  }
  codec_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codec);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.SpeechHeader.codec)
}

// optional string vt = 4;
inline void SpeechHeader::clear_vt() {
  vt_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SpeechHeader::vt() const {
  // @@protoc_insertion_point(field_get:rokid.open.SpeechHeader.vt)
  return vt_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeechHeader::set_vt(const ::std::string& value) {
  
  vt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.SpeechHeader.vt)
}
inline void SpeechHeader::set_vt(const char* value) {
  
  vt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.SpeechHeader.vt)
}
inline void SpeechHeader::set_vt(const char* value, size_t size) {
  
  vt_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.SpeechHeader.vt)
}
inline ::std::string* SpeechHeader::mutable_vt() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.SpeechHeader.vt)
  return vt_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpeechHeader::release_vt() {
  // @@protoc_insertion_point(field_release:rokid.open.SpeechHeader.vt)
  
  return vt_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeechHeader::set_allocated_vt(::std::string* vt) {
  if (vt != NULL) {
    
  } else {
    
  }
  vt_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), vt);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.SpeechHeader.vt)
}

// optional string cdomain = 5;
inline void SpeechHeader::clear_cdomain() {
  cdomain_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SpeechHeader::cdomain() const {
  // @@protoc_insertion_point(field_get:rokid.open.SpeechHeader.cdomain)
  return cdomain_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeechHeader::set_cdomain(const ::std::string& value) {
  
  cdomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.SpeechHeader.cdomain)
}
inline void SpeechHeader::set_cdomain(const char* value) {
  
  cdomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.SpeechHeader.cdomain)
}
inline void SpeechHeader::set_cdomain(const char* value, size_t size) {
  
  cdomain_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.SpeechHeader.cdomain)
}
inline ::std::string* SpeechHeader::mutable_cdomain() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.SpeechHeader.cdomain)
  return cdomain_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpeechHeader::release_cdomain() {
  // @@protoc_insertion_point(field_release:rokid.open.SpeechHeader.cdomain)
  
  return cdomain_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeechHeader::set_allocated_cdomain(::std::string* cdomain) {
  if (cdomain != NULL) {
    
  } else {
    
  }
  cdomain_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), cdomain);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.SpeechHeader.cdomain)
}

// optional string device = 6;
inline void SpeechHeader::clear_device() {
  device_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& SpeechHeader::device() const {
  // @@protoc_insertion_point(field_get:rokid.open.SpeechHeader.device)
  return device_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeechHeader::set_device(const ::std::string& value) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:rokid.open.SpeechHeader.device)
}
inline void SpeechHeader::set_device(const char* value) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:rokid.open.SpeechHeader.device)
}
inline void SpeechHeader::set_device(const char* value, size_t size) {
  
  device_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:rokid.open.SpeechHeader.device)
}
inline ::std::string* SpeechHeader::mutable_device() {
  
  // @@protoc_insertion_point(field_mutable:rokid.open.SpeechHeader.device)
  return device_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* SpeechHeader::release_device() {
  // @@protoc_insertion_point(field_release:rokid.open.SpeechHeader.device)
  
  return device_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void SpeechHeader::set_allocated_device(::std::string* device) {
  if (device != NULL) {
    
  } else {
    
  }
  device_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), device);
  // @@protoc_insertion_point(field_set_allocated:rokid.open.SpeechHeader.device)
}

inline const SpeechHeader* SpeechHeader::internal_default_instance() {
  return &SpeechHeader_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace open
}  // namespace rokid

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_speech_2eproto__INCLUDED
